(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{391:function(s,a,n){s.exports=n.p+"assets/img/image-20230707213018944.1fcca3a6.png"},392:function(s,a,n){s.exports=n.p+"assets/img/image-20230707213036677.9468c136.png"},393:function(s,a,n){s.exports=n.p+"assets/img/image-20230707213102631.ae839fc5.png"},394:function(s,a,n){s.exports=n.p+"assets/img/image-20230707213130507.731fd5d5.png"},395:function(s,a,n){s.exports=n.p+"assets/img/image-20230707213142431.13571893.png"},475:function(s,a,n){"use strict";n.r(a);var t=n(4),e=Object(t.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"_1-调用栈中的数据是如何回收的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-调用栈中的数据是如何回收的"}},[s._v("#")]),s._v(" 1.调用栈中的数据是如何回收的")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" b "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("name")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('" 极客邦 "')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("showName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" c "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('" 极客时间 "')]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" d "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("name")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('" 极客时间 "')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("showName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("p",[t("img",{attrs:{src:n(391),alt:"Algolia搜索"}})]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("如果执行到 showName 函数时，那么 JavaScript 引\n擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用\n栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录\n当前执行状态的指针（称为 "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ESP")]),s._v("），指向调用栈中 showName 函数的执行上下文，表示\n当前正在执行 showName 函数。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需\n要销毁 showName 函数的执行上下文了。"),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ESP")]),s._v(" 这时候就帮上忙了，JavaScript 会将 "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ESP")]),s._v("\n下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过\n程。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[t("img",{attrs:{src:n(392),alt:"Algolia搜索"}})]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("当 showName 函数执行结束之后，"),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ESP")]),s._v(" 向下移动到 foo 函数的执行上\n下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比\n如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函\n数的执行上下文。\n所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ESP")]),s._v(" 来销毁该函数保\n存在栈中的执行上下文。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("h2",{attrs:{id:"_2-堆中的数据是如何回收的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-堆中的数据是如何回收的"}},[s._v("#")]),s._v(" 2.堆中的数据是如何回收的")]),s._v(" "),t("h3",{attrs:{id:"_2-1代际假说"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1代际假说"}},[s._v("#")]),s._v(" 2.1代际假说")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("不过在正式介绍 "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("V8")]),s._v(" 是如何实现回收之前，你需要先学习下代际假说（The Generational\nHypothesis）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建\n立在该假说的基础之上的，所以很是重要。\n代际假说有以下两个特点：\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1.")]),s._v("第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，\n很快就变得不可访问；\n"),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.")]),s._v("第二个是不死的对象，会活得更久。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("所以，在 "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("V8")]),s._v(" 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。\n\n新生区通常只支持 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("V8")]),s._v(" 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。\n副垃圾回收器，主要负责新生代的垃圾回收。\n主垃圾回收器，主要负责老生代的垃圾回收。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("h3",{attrs:{id:"_2-2垃圾回收器的工作流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2垃圾回收器的工作流程"}},[s._v("#")]),s._v(" 2.2垃圾回收器的工作流程")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//无论什么类型的垃圾回收器，它们都有一套共同的执行流程。")]),s._v("\n第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对\n象就是可以进行垃圾回收的对象。\n第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中\n所有被标记为可回收的对象。\n第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们\n把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分\n配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎\n片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍\n的副垃圾回收器。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br")])]),t("h3",{attrs:{id:"_2-3副垃圾回收器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3副垃圾回收器"}},[s._v("#")]),s._v(" 2.3副垃圾回收器")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两\n个区域，一半是对象区域，一半是空闲区域，如下图所示：\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[t("img",{attrs:{src:n(393),alt:"Algolia搜索"}})]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操\n作。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶\n段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排\n列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存\n碎片了。完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原\n来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操\n作还能让新生代中的这两块区域无限重复使用下去。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从\n对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么\n每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。\n也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问\n题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，\n会被移动到老生区中。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("h3",{attrs:{id:"_2-4主垃圾回收器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4主垃圾回收器"}},[s._v("#")]),s._v(" 2.4主垃圾回收器")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直\n接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对\n象存活时间长。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些\n大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。\n因而，主垃圾回收器是采用 "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。下面我")]),s._v("\n们来看看该算法是如何工作的。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历\n过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。\n清除算\n法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内\n存，于是又产生了另外一种算法——"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//标记 - 整理（Mark-Compact），这个标记过程仍然")]),s._v("\n与标记 "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v(" 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所\n有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("h3",{attrs:{id:"_2-5全停顿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5全停顿"}},[s._v("#")]),s._v(" 2.5全停顿")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("由于JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的\nJavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停\n顿（Stop"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("The"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("World）。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[t("img",{attrs:{src:n(394),alt:"Algolia搜索"}})]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("在 "),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("V8")]),s._v(" 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但\n老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展\n示的那样，花费了 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("200")]),s._v(" 毫秒，在这 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("200")]),s._v(" 毫秒内，主线程是不能做其他事情的。比如页面正\n在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("200")]),s._v(" 毫秒内\n无法执行的，这将会造成页面的卡顿现象。\n为了降低老生代的垃圾回收而造成的卡顿，"),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("V8")]),s._v(" 将标记过程分为一个个的子标记过程，同时\n让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//为增量标记（Incremental Marking）算法。如下图所示：")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[t("img",{attrs:{src:n(395),alt:"Algolia搜索"}})]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执\n行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果\n时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])])])}),[],!1,null,null,null);a.default=e.exports}}]);