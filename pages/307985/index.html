<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue2面试大全 | hyh的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="页面的描述">
    
    <link rel="preload" href="/myblog/assets/css/0.styles.99ff47a3.css" as="style"><link rel="preload" href="/myblog/assets/js/app.86e991b9.js" as="script"><link rel="preload" href="/myblog/assets/js/2.dd8fbd6f.js" as="script"><link rel="preload" href="/myblog/assets/js/35.d743471b.js" as="script"><link rel="prefetch" href="/myblog/assets/js/10.a692fbd4.js"><link rel="prefetch" href="/myblog/assets/js/11.08388110.js"><link rel="prefetch" href="/myblog/assets/js/12.9304c561.js"><link rel="prefetch" href="/myblog/assets/js/13.875e3a6f.js"><link rel="prefetch" href="/myblog/assets/js/14.ab4a6449.js"><link rel="prefetch" href="/myblog/assets/js/15.ef10c68f.js"><link rel="prefetch" href="/myblog/assets/js/16.47e9b371.js"><link rel="prefetch" href="/myblog/assets/js/17.7e5bedb7.js"><link rel="prefetch" href="/myblog/assets/js/18.867a9263.js"><link rel="prefetch" href="/myblog/assets/js/19.262467ab.js"><link rel="prefetch" href="/myblog/assets/js/20.75e64baf.js"><link rel="prefetch" href="/myblog/assets/js/21.6d5140dd.js"><link rel="prefetch" href="/myblog/assets/js/22.93df3f05.js"><link rel="prefetch" href="/myblog/assets/js/23.489f97d2.js"><link rel="prefetch" href="/myblog/assets/js/24.26faffd1.js"><link rel="prefetch" href="/myblog/assets/js/25.24c29789.js"><link rel="prefetch" href="/myblog/assets/js/26.55467329.js"><link rel="prefetch" href="/myblog/assets/js/27.4ee20d4a.js"><link rel="prefetch" href="/myblog/assets/js/28.c0b00ac6.js"><link rel="prefetch" href="/myblog/assets/js/29.035e723a.js"><link rel="prefetch" href="/myblog/assets/js/3.39ee49ac.js"><link rel="prefetch" href="/myblog/assets/js/30.7f225a86.js"><link rel="prefetch" href="/myblog/assets/js/31.2fe01be4.js"><link rel="prefetch" href="/myblog/assets/js/32.76fdc062.js"><link rel="prefetch" href="/myblog/assets/js/33.f56c013e.js"><link rel="prefetch" href="/myblog/assets/js/34.2e1a7181.js"><link rel="prefetch" href="/myblog/assets/js/36.077f181c.js"><link rel="prefetch" href="/myblog/assets/js/37.d0b5c7d8.js"><link rel="prefetch" href="/myblog/assets/js/38.9cabfb87.js"><link rel="prefetch" href="/myblog/assets/js/39.d22ebb14.js"><link rel="prefetch" href="/myblog/assets/js/4.e647fabc.js"><link rel="prefetch" href="/myblog/assets/js/40.9d424e42.js"><link rel="prefetch" href="/myblog/assets/js/41.ce4ee263.js"><link rel="prefetch" href="/myblog/assets/js/42.cf08eca3.js"><link rel="prefetch" href="/myblog/assets/js/43.84ae1707.js"><link rel="prefetch" href="/myblog/assets/js/44.d84ba1e9.js"><link rel="prefetch" href="/myblog/assets/js/45.79c1ad03.js"><link rel="prefetch" href="/myblog/assets/js/46.2faccb6b.js"><link rel="prefetch" href="/myblog/assets/js/47.f036d8e9.js"><link rel="prefetch" href="/myblog/assets/js/48.03cc22dc.js"><link rel="prefetch" href="/myblog/assets/js/49.4c0377a0.js"><link rel="prefetch" href="/myblog/assets/js/5.ab7fc5be.js"><link rel="prefetch" href="/myblog/assets/js/50.6730761e.js"><link rel="prefetch" href="/myblog/assets/js/51.421c10a9.js"><link rel="prefetch" href="/myblog/assets/js/52.9d64c6f3.js"><link rel="prefetch" href="/myblog/assets/js/53.365bcff0.js"><link rel="prefetch" href="/myblog/assets/js/54.d92d0c4d.js"><link rel="prefetch" href="/myblog/assets/js/55.e9a59a8e.js"><link rel="prefetch" href="/myblog/assets/js/56.38aae51f.js"><link rel="prefetch" href="/myblog/assets/js/57.5e1e990c.js"><link rel="prefetch" href="/myblog/assets/js/58.7ecb1984.js"><link rel="prefetch" href="/myblog/assets/js/59.3c946394.js"><link rel="prefetch" href="/myblog/assets/js/6.e25ccbc3.js"><link rel="prefetch" href="/myblog/assets/js/60.71e29c5d.js"><link rel="prefetch" href="/myblog/assets/js/61.e02109cf.js"><link rel="prefetch" href="/myblog/assets/js/62.84b4ecc3.js"><link rel="prefetch" href="/myblog/assets/js/63.9b9860ad.js"><link rel="prefetch" href="/myblog/assets/js/64.5cb2ea95.js"><link rel="prefetch" href="/myblog/assets/js/65.015e710f.js"><link rel="prefetch" href="/myblog/assets/js/66.36c974d0.js"><link rel="prefetch" href="/myblog/assets/js/67.d8808437.js"><link rel="prefetch" href="/myblog/assets/js/68.66d60f36.js"><link rel="prefetch" href="/myblog/assets/js/69.00a72619.js"><link rel="prefetch" href="/myblog/assets/js/7.7e952e17.js"><link rel="prefetch" href="/myblog/assets/js/70.59e4b15d.js"><link rel="prefetch" href="/myblog/assets/js/71.996c38dd.js"><link rel="prefetch" href="/myblog/assets/js/72.5fce5eb4.js"><link rel="prefetch" href="/myblog/assets/js/73.7a7c6a63.js"><link rel="prefetch" href="/myblog/assets/js/74.c94665e5.js"><link rel="prefetch" href="/myblog/assets/js/75.9bdf7dad.js"><link rel="prefetch" href="/myblog/assets/js/76.791addff.js"><link rel="prefetch" href="/myblog/assets/js/77.fdb935e6.js"><link rel="prefetch" href="/myblog/assets/js/78.28c527d5.js"><link rel="prefetch" href="/myblog/assets/js/79.c9e40709.js"><link rel="prefetch" href="/myblog/assets/js/8.830dd035.js"><link rel="prefetch" href="/myblog/assets/js/80.c0d96193.js"><link rel="prefetch" href="/myblog/assets/js/81.418c0eee.js"><link rel="prefetch" href="/myblog/assets/js/82.96138a02.js"><link rel="prefetch" href="/myblog/assets/js/83.35b8c102.js"><link rel="prefetch" href="/myblog/assets/js/84.3389ac8e.js"><link rel="prefetch" href="/myblog/assets/js/85.62df5e4c.js"><link rel="prefetch" href="/myblog/assets/js/86.396bc322.js"><link rel="prefetch" href="/myblog/assets/js/9.62e3bf9b.js">
    <link rel="stylesheet" href="/myblog/assets/css/0.styles.99ff47a3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myblog/" class="home-link router-link-active"><!----> <span class="site-name">hyh的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myblog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端三剑客" class="dropdown-title"><!----> <span class="title" style="display:;">前端三剑客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/javascript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/myblog/blogs/basics/data.html" class="nav-link">前端资料网站</a></div><div class="nav-item"><a href="/myblog/blogs/basics/i18n.html" class="nav-link">国际化i18n</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/myblog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端三剑客" class="dropdown-title"><!----> <span class="title" style="display:;">前端三剑客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/javascript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/myblog/blogs/basics/data.html" class="nav-link">前端资料网站</a></div><div class="nav-item"><a href="/myblog/blogs/basics/i18n.html" class="nav-link">国际化i18n</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/myblog/" aria-current="page" class="sidebar-link">博客简介</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试篇</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/pages/6cbb94/" class="sidebar-link">html面试题大全</a></li><li><a href="/myblog/pages/828be1/" class="sidebar-link">css面试题大全</a></li><li><a href="/myblog/pages/21b7bd/" class="sidebar-link">js面试题大全</a></li><li><a href="/myblog/pages/307985/" aria-current="page" class="active sidebar-link">vue2面试题大全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_1-什么是虚拟dom" class="sidebar-link">1.什么是虚拟DOM</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_2-vue就地复用策略" class="sidebar-link">2.vue就地复用策略</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_3-请解释什么是单页面应用-single-page-app-以及如何使其对搜索引擎友好" class="sidebar-link">3.请解释什么是单页面应用(single page app),以及如何使其对搜索引擎友好</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_4-组件中的data为什么是一个函数" class="sidebar-link">4.组件中的data为什么是一个函数？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_5-为什么v-for和v-if不建议用在一起" class="sidebar-link">5.为什么v-for和v-if不建议用在一起</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_6-vue中key的作用" class="sidebar-link">6.vue中key的作用</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_7-说说mvvm模型" class="sidebar-link">7.说说MVVM模型</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_8-说一下什么是vue生命周期函数" class="sidebar-link">8.说一下什么是vue生命周期函数</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_9-说说什么是单页面应用程序-优缺点" class="sidebar-link">9.说说什么是单页面应用程序 优缺点</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_10-说说为什么vue是异步更新dom" class="sidebar-link">10.说说为什么vue是异步更新DOM</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_11-说一下vue2生命周期" class="sidebar-link">11.说一下vue2生命周期</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_12-说一下jquery和vue的区别" class="sidebar-link">12.说一下jquery和vue的区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_13-说一下vuex中的mutation函数为什么必须是异步的" class="sidebar-link">13.说一下Vuex中的mutation函数为什么必须是异步的</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_14-设计模式有哪些" class="sidebar-link">14.设计模式有哪些</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_15-mvvm是怎么实现的" class="sidebar-link">15.MVVM是怎么实现的</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_16-vue中组件通信方式" class="sidebar-link">16.vue中组件通信方式</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_17-diff算法" class="sidebar-link">17.diff算法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_18-vue-use原理" class="sidebar-link">18.Vue.use原理</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_19-为什么刷新页面vuex数据会丢失" class="sidebar-link">19.为什么刷新页面vuex数据会丢失</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_20-vuex是干嘛的-属性怎么使用" class="sidebar-link">20.vuex是干嘛的，属性怎么使用</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_21-vue2实现响应式的原理和缺陷" class="sidebar-link">21.vue2实现响应式的原理和缺陷</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_22-说一说-vue-的-keep-alive" class="sidebar-link">22.说一说 vue 的 keep-alive ？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_23-说一说vue-router-实现懒加载的方法" class="sidebar-link">23.说一说vue-router 实现懒加载的方法？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_24-说一说computed和watch的区别" class="sidebar-link">24.说一说computed和watch的区别？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_25-vue中刷新页面的方式有哪些" class="sidebar-link">25.vue中刷新页面的方式有哪些</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_26-说一下登录流程" class="sidebar-link">26.说一下登录流程</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_27-vue实例最后挂载到哪个标签上的" class="sidebar-link">27.vue实例最后挂载到哪个标签上的</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_28-token是什么-加密" class="sidebar-link">28.token是什么？（加密）</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_29-说一下双向数据绑定" class="sidebar-link">29.说一下双向数据绑定</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_30-vue自定义指令" class="sidebar-link">30.vue自定义指令</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_31-vue中的computed和data里面的数据以及props可以同名吗" class="sidebar-link">31.vue中的computed和data里面的数据以及props可以同名吗</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_32-vue中数组的哪些方法可以触发视图的更新-哪些不可以-有什么解决办法" class="sidebar-link">32.vue中数组的哪些方法可以触发视图的更新，哪些不可以，有什么解决办法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_33-说一下路由的传参方式" class="sidebar-link">33.说一下路由的传参方式</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_34-说一下router模式" class="sidebar-link">34.说一下router模式</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#路由的按需加载" class="sidebar-link">路由的按需加载</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_35-说一下vue动态组件" class="sidebar-link">35.说一下vue动态组件</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_36-自定义指令" class="sidebar-link">36.自定义指令</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_37-说一下vue中的插槽" class="sidebar-link">37.说一下vue中的插槽</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_38-说一下路由守卫" class="sidebar-link">38.说一下路由守卫</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_39-vue-的父子组件生命周期钩子函数执行顺序" class="sidebar-link">39.Vue 的父子组件生命周期钩子函数执行顺序</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_40-当new-vue发生了什么" class="sidebar-link">40.当new Vue发生了什么</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_41-vue-loader是什么-使用它的用途有哪些" class="sidebar-link">41.vue-loader是什么？使用它的用途有哪些？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_42-常见的vue事件修饰符" class="sidebar-link">42.常见的vue事件修饰符</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_43-ajax请求代码应该写在组件的methods中还是vuex的actions中" class="sidebar-link">43.ajax请求代码应该写在组件的methods中还是vuex的actions中</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_44-vuex的严格模式是什么-有什么作用-怎么开启" class="sidebar-link">44.Vuex的严格模式是什么,有什么作用,怎么开启？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_45-mutation和action有什么区别" class="sidebar-link">45.mutation和action有什么区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_46-在v-model上怎么用vuex中state的值" class="sidebar-link">46.在v-model上怎么用Vuex中state的值？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_47-vue里面router-link在电脑上有用-在安卓上没反应怎么解决" class="sidebar-link">47.Vue里面router-link在电脑上有用，在安卓上没反应怎么解决</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_48-vue2中注册在router-link上事件无效解决方法" class="sidebar-link">48.Vue2中注册在router-link上事件无效解决方法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_49-vue中如何统一监听组件报错" class="sidebar-link">49.vue中如何统一监听组件报错</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_50-过滤器是什么-怎么实现" class="sidebar-link">50.过滤器是什么，怎么实现</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_51-说一下常见的事件修饰符" class="sidebar-link">51.说一下常见的事件修饰符</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_52-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决" class="sidebar-link">52.Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/307985/#_53-vue-模板是如何编译的-经历了哪些过程" class="sidebar-link">53.Vue 模板是如何编译的？经历了哪些过程？</a></li></ul></li><li><a href="/myblog/pages/e2ab2a/" class="sidebar-link">vue3面试题大全</a></li><li><a href="/myblog/pages/a1fd8f/" class="sidebar-link">浏览器面试题大全</a></li><li><a href="/myblog/pages/ceafae/" class="sidebar-link">性能优化</a></li><li><a href="/myblog/pages/291559/" class="sidebar-link">个人面试经历</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>es6基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ajax基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>git基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue2基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue3基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>lodash基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器基础篇</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-41062720><div class="articleInfo" data-v-41062720><ul class="breadcrumbs" data-v-41062720><li data-v-41062720><a href="/myblog/" title="首页" class="iconfont icon-home router-link-active" data-v-41062720></a></li> <li data-v-41062720><a href="/myblog/categories/?category=blogs" title="分类" data-v-41062720>blogs</a></li><li data-v-41062720><a href="/myblog/categories/?category=VUE" title="分类" data-v-41062720>VUE</a></li></ul> <div class="info" data-v-41062720><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-41062720><a href="javascript:;" data-v-41062720>2023-07-04</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">vue2面试大全<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="_1-什么是虚拟dom"><a href="#_1-什么是虚拟dom" class="header-anchor">#</a> 1.什么是虚拟DOM</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>面试题 ？什么是虚拟dom  vitural dom 
        <span class="token comment">// =&gt; 虚拟dom 就是 =&gt; 用来保存节点信息, 描述真实dom的JavaScript对象</span>
优点：无需手动操作 <span class="token constant">DOM</span>： 我们不再需要手动去操作 <span class="token constant">DOM</span>，只需要写好 View<span class="token operator">-</span>Model 的代码逻辑，框架会根据虚拟 <span class="token constant">DOM</span> 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
缺点：无法进行极致优化： 虽然虚拟 <span class="token constant">DOM</span> <span class="token operator">+</span> 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 <span class="token constant">DOM</span> 无法进行针对性的极致优化。首次渲染大量<span class="token constant">DOM</span>时，由于多了一层虚拟<span class="token constant">DOM</span>的计算，会比innerHTML插入慢。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_2-vue就地复用策略"><a href="#_2-vue就地复用策略" class="header-anchor">#</a> 2.vue就地复用策略</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>就地复用：vue会尽可能的同层级同位置， 对比虚拟dom，复用旧的dom结构，进行差异化更新
好处：可以复用旧的dom结构，提高渲染效率
设置了key，相当于给这个li标签加了一个标记，
新旧虚拟dom对比的时候，就会按着key的值 对比原来的那个标签
<span class="token comment">//就是相当于，当我们以数组的index作为key，然后比如我们在数组的开头加了一个元素，再去渲染页面时，首先根据标识一样的去对比，</span>
<span class="token comment">//如果内容结构一样就复用，不一样就生成，提高页面渲染的效率</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_3-请解释什么是单页面应用-single-page-app-以及如何使其对搜索引擎友好"><a href="#_3-请解释什么是单页面应用-single-page-app-以及如何使其对搜索引擎友好" class="header-anchor">#</a> 3.请解释什么是单页面应用(single page app),以及如何使其对搜索引擎友好</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>什么是单页面应用：
指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源
<span class="token constant">MPA</span>多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新
解决单页面页面首次加载速度慢
<span class="token number">1.</span>路由懒加载，最开始不需要展示的页面，就利用懒加载
<span class="token number">2.</span>浏览器缓存 利用浏览器缓存来存储静态资源
<span class="token number">3.</span>打包js css 文件，减少代码体积
<span class="token number">4.</span>使用<span class="token constant">CDN</span>内容分发网络 将静态资源部署到 <span class="token constant">CDN</span> 上，可以使用户从最近的服务器获取资源，从而加速首屏加载速度。
<span class="token number">5.</span>使用服务端渲染和预渲染
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>如何使其对搜索引擎友好</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>预渲染
<span class="token number">2.</span><span class="token constant">SSR</span><span class="token punctuation">(</span>服务端渲染<span class="token punctuation">)</span><span class="token comment">//指的是我们页面的渲染操作不是在浏览器了，而是服务端，服务端直接返回给我们html</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_4-组件中的data为什么是一个函数"><a href="#_4-组件中的data为什么是一个函数" class="header-anchor">#</a> 4.组件中的data为什么是一个函数？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。
<span class="token number">2.</span>因为，在<span class="token keyword">new</span> <span class="token class-name">Vue</span>的时候传入我们的配置项$options<span class="token punctuation">,</span>之后执行<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>把配置项传进去，然后_init在内部做了很多操作，我们重点看那个<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_initState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  initState函数按顺序初始化$options的数据，顺序为 prop<span class="token operator">&gt;</span>methods<span class="token operator">&gt;</span>data<span class="token operator">&gt;</span>computed<span class="token operator">&gt;</span>watch<span class="token punctuation">,</span>在我们初始化data时，会调用<span class="token keyword">this</span><span class="token punctuation">.</span>_initData<span class="token punctuation">,</span>在这个initData中 将vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data 赋值给vm<span class="token punctuation">.</span>_data，如果说我们data是一个对象，则所有的vue实例都能修改data对象里面的属性，因为他们引用的对象指向同一个地址
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_5-为什么v-for和v-if不建议用在一起"><a href="#_5-为什么v-for和v-if不建议用在一起" class="header-anchor">#</a> 5.为什么v-for和v-if不建议用在一起</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">.</span>当 v<span class="token operator">-</span><span class="token keyword">for</span> 和 v<span class="token operator">-</span><span class="token keyword">if</span> 处于同一个节点时，v<span class="token operator">-</span><span class="token keyword">for</span> 的优先级比 v<span class="token operator">-</span><span class="token keyword">if</span> 更高
这意味着 v<span class="token operator">-</span><span class="token keyword">if</span> 将分别重复运行于每个 v<span class="token operator">-</span><span class="token keyword">for</span> 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费（Vue2<span class="token punctuation">.</span>x）
<span class="token number">2.</span>这种场景建议使用 computed 计算属性，先对数据进行过滤
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_6-vue中key的作用"><a href="#_6-vue中key的作用" class="header-anchor">#</a> 6.vue中key的作用</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>key的作用
<span class="token number">1.</span>是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟<span class="token constant">DOM</span>
如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。
key也不能是元素的index，因为假设我们给数组前插入一个新元素，它的下标是<span class="token number">0</span>，那么和原来的第一个元素重复了，整个数组的key都发生了改变，这样就跟没有key的情况一样了
<span class="token number">2.</span>第一种情况是 v<span class="token operator">-</span><span class="token keyword">if</span> 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v<span class="token operator">-</span><span class="token keyword">if</span> 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。
但是只是vue2有这个缺点，vue3没有

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_7-说说mvvm模型"><a href="#_7-说说mvvm模型" class="header-anchor">#</a> 7.说说MVVM模型</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">MVVM</span>模型 ：一种软件设计模式   是Model 和View 和ViewMolde的简写
 <span class="token comment">// M:Model 代表数据模型，数据和业务逻辑都在 Model 层中定义。（对应data中的数据和业务逻辑）</span>
<span class="token comment">// V:View 代表UI视图,也就是用户界面，负责数据的展示。 （对应着template模板，负责数据的展示）</span>
<span class="token comment">// VM:viewModel 也叫做视图数据连接层, 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作, （对应着我们的vue实例)</span>
<span class="token constant">MVC</span> 模型是model 数据模型 view 视图 controller 控制器 ，原生js操作dom的一种方式
问题： 展示 js 中的变量，需要 innerText textContent innerHTML  <span class="token number">1.</span> xss 攻击  <span class="token number">2.</span>字符串需要编译之后才能生成 dom 性能差
    <span class="token comment">// 什么模式? MVC —— 模型视图控制器 —— 彼此割裂</span>
     <span class="token comment">// 什么叫做模式？ —— 一种解决问题的套路</span>
<span class="token constant">MVVM</span>（Model<span class="token operator">-</span>View<span class="token operator">-</span><span class="token function">ViewModel）是一种用于构建用户界面的软件架构模式，它将应用程序分成三个部分：模型</span><span class="token punctuation">(</span>model<span class="token punctuation">)</span><span class="token function">、视图</span><span class="token punctuation">(</span>view<span class="token punctuation">)</span><span class="token function">和视图模型</span><span class="token punctuation">(</span>viewModel<span class="token punctuation">)</span>。视图模型通常负责维护模型状态，并同步视图以反映模型的变化。
在<span class="token constant">MVVM</span>中，发布订阅者模式通常被用来实现视图模型和视图之间的通信，例如当数据发生变化时通知视图进行更新。Vue<span class="token punctuation">.</span>js就是基于这种观察者模式设计的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_8-说一下什么是vue生命周期函数"><a href="#_8-说一下什么是vue生命周期函数" class="header-anchor">#</a> 8.说一下什么是vue生命周期函数</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>首先 vue生命周期函数是vue框架提供的内置函数 ，在不同的阶段自动执行
<span class="token number">1.</span>数据初始化阶段 <span class="token number">2.</span> 挂载dom阶段 <span class="token number">3.</span>数据更新阶段 <span class="token number">4.</span>组件销毁阶段
<span class="token number">1.</span> beforeCreate：data数据初始化之前，组件还没有数据
<span class="token number">2.</span> <span class="token literal-property property">created</span><span class="token operator">:</span> data数据初始化之后，可以获取到组件的数据
<span class="token number">3.</span> beforeMount：<span class="token constant">DOM</span>挂载到页面之前，<span class="token constant">DOM</span>还未挂载
<span class="token number">4.</span> mounted：<span class="token constant">DOM</span>挂载之后，可以操作<span class="token constant">DOM</span>了
<span class="token number">5.</span> <span class="token literal-property property">beforeUpdate</span><span class="token operator">:</span> 数据更新，<span class="token constant">DOM</span>更新前  <span class="token comment">//组件更新前 ---&gt;数据是新的，页面是旧的 虚拟dom还没有对比重新渲染~~</span>
<span class="token number">6.</span> <span class="token literal-property property">updated</span><span class="token operator">:</span> 数据更新，<span class="token constant">DOM</span>更新后
<span class="token number">7.</span> <span class="token literal-property property">beforeDestroy</span><span class="token operator">:</span> 组件销毁前   <span class="token comment">// 组件销毁前 ——组件实例依然还保留全部的功能 // 全局的定时器，不会自动销毁，需要手动关闭~~</span>
<span class="token number">8.</span> <span class="token literal-property property">destroyed</span><span class="token operator">:</span> 组件销毁后
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_9-说说什么是单页面应用程序-优缺点"><a href="#_9-说说什么是单页面应用程序-优缺点" class="header-anchor">#</a> 9.说说什么是单页面应用程序 优缺点</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>单页面应用程序：指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。
多页面应用程序：<span class="token constant">MPA</span>多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新
优点：
<span class="token number">1.</span> 传统的多页面应用程序，每次请求服务器返回的都是一整个完整的页面
<span class="token number">2.</span> 单页面应用程序只有第一次会加载完整的页面
<span class="token number">3.</span> 以后每次请求仅仅获取必要的数据，减少了请求体积，加快页面响应速度，降低了对服务器的压力
<span class="token number">4.</span> <span class="token constant">SPA</span>更好的用户体验，运行更加流畅
<span class="token literal-property property">缺点</span><span class="token operator">:</span>
<span class="token number">1.</span>不利于 <span class="token constant">SEO</span> 搜索引擎优化 谷歌浏览器在解决这个问题 ssr<span class="token operator">:</span>服务端渲染 server side rendering
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_10-说说为什么vue是异步更新dom"><a href="#_10-说说为什么vue是异步更新dom" class="header-anchor">#</a> 10.说说为什么vue是异步更新DOM</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>提高性能，将多次修改dom，存起来，一次性更新
<span class="token literal-property property">原理</span><span class="token operator">:</span>因为虚拟<span class="token constant">DOM</span>只需要一次就可以将整个组件的<span class="token constant">DOM</span>更新到最新，当dom更新了后，vue侦听器侦听到了，会先判断任务队列中有没有渲染操作的函数，保证不重复，然后只需要将渲染操作推迟到本轮事件循环的最后或者下一轮事件循环。
<span class="token number">2.</span><span class="token punctuation">(</span>vue更新dom后是异步的调用了render函数和diff算法<span class="token punctuation">,</span>这时无论后面有多少修改dom的操作，vue也只会在本轮事件循环执行完之前或下一次事件循环之前，更新dom，所以我们同步或异步的操作dom，都会存起来一次性更新<span class="token punctuation">)</span>
也就是说，只需要在本轮事件循环的最后，等前面更新状态的语句都执行完之后，执行一次渲染操作，它就可以无视前面各种更新状态的语法，无论前面写了多少条更新状态的语句，只在最后渲染一次就可以了，Vue的更新操作默认会将执行渲染操作的函数添加到微任务队列中
<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token function">在钩子函数created</span><span class="token punctuation">(</span><span class="token punctuation">)</span>里面想要获取操作Dom，<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">把操作DOM的方法放在$nextTick中</span><span class="token template-punctuation string">`</span></span>
但为什么vue是异步更新dom，<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>为什么一定比它慢<span class="token operator">?</span>
    不一定的<span class="token punctuation">,</span>看修改的顺序，如果在<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>下面修改dom了，<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>就获取不到
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>$nextTick原理</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>nextTick 在内部做了一个优雅降级的操作，首先判断当前环境和浏览器支不不支持Promise，判断Promise 是不是<span class="token keyword">undefined</span> ，调用isNative方法，isNative方法，是把Promise传进去，判断Promise是不是一个函数，以及用正则判断Promise被toString字符串化，是不是包含native code 初始的时候返回<span class="token boolean">true</span>则使用promise<span class="token punctuation">,</span>返回<span class="token boolean">false</span>则判断MutationObserver 以及setImmediate最后setTimeout兜底
 <span class="token keyword">function</span> <span class="token function">isNative</span><span class="token punctuation">(</span><span class="token parameter">Ctor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> Ctor <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">native code</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_11-说一下vue2生命周期"><a href="#_11-说一下vue2生命周期" class="header-anchor">#</a> 11.说一下vue2生命周期</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>钩子函数用来描述一个组件从引入到退出的全过程中的某个过程，整个过程称为生命周期。 <span class="token parameter">钩子函数按照组件生命周期的过程分为，挂载阶段</span><span class="token operator">=&gt;</span><span class="token parameter">更新阶段</span><span class="token operator">=&gt;</span>销毁阶段
<span class="token number">1.</span> beforeCreate：data数据初始化之前，组件还没有数据
<span class="token number">2.</span> <span class="token literal-property property">created</span><span class="token operator">:</span> data数据初始化之后，可以获取到组件的数据
<span class="token number">3.</span> beforeMount：<span class="token constant">DOM</span>挂载到页面之前，<span class="token constant">DOM</span>还未挂载
<span class="token number">4.</span> mounted：<span class="token constant">DOM</span>挂载之后，可以操作<span class="token constant">DOM</span>了
<span class="token number">5.</span> <span class="token literal-property property">beforeUpdate</span><span class="token operator">:</span> 数据更新，<span class="token constant">DOM</span>更新前  <span class="token comment">//组件更新前 ---&gt;数据是新的，页面是旧的 虚拟dom还没有对比重新渲染~~</span>
<span class="token number">6.</span> <span class="token literal-property property">updated</span><span class="token operator">:</span> 数据更新，<span class="token constant">DOM</span>更新后
<span class="token number">7.</span> <span class="token literal-property property">beforeDestroy</span><span class="token operator">:</span> 组件销毁前   <span class="token comment">// 组件销毁前 ——组件实例依然还保留全部的功能 // 全局的定时器，不会自动销毁，需要手动关闭~~</span>
<span class="token number">8.</span> <span class="token literal-property property">destroyed</span><span class="token operator">:</span> 组件销毁后
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_12-说一下jquery和vue的区别"><a href="#_12-说一下jquery和vue的区别" class="header-anchor">#</a> 12.说一下jquery和vue的区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">jquery</span><span class="token operator">:</span>命令式   ：jQuery是命令式的操作<span class="token constant">DOM</span>，命令式的局部更新视图   
vue：声明式     ：我们不再需要关注怎么操作<span class="token constant">DOM</span>，因为框架会帮我们自动去做，我们只关注状态就好了。  易维护
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_13-说一下vuex中的mutation函数为什么必须是异步的"><a href="#_13-说一下vuex中的mutation函数为什么必须是异步的" class="header-anchor">#</a> 13.说一下Vuex中的mutation函数为什么必须是异步的</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 为什么mutation必须是同步的</span>
<span class="token comment">// 在Vue.js和其他一些前端JavaScript框架中，为什么mutation必须是同步的呢?</span>
<span class="token comment">// 这是因为Vue.js采用了一种基于数据驱动的设计模式，其中状态(state)存储在Vuex存储store)中。为了使Vuex存储在任何时候都保持一致性，必须保证状态的更改是可预测的</span>
<span class="token comment">// 因此，Vuex要求mutation是同步的，这样才能保证状态的变更在任何时候都是可预测的。异步操作可能会导致状态的更改不可预测，并导致问题。</span>
<span class="token comment">// 同时，异步操作通常会导致更多的复杂性，并且Vuex中的操作必须是可追踪的，以便调试和跟踪状态的变化。同步操作可以更容易地进行跟踪和调试，因此强制同步是有意义的。</span>
<span class="token comment">//如果是异步的话，vue调试工具不知道这个异步函数是什么时候调用的，导致了数据的不可预测，并导致问题</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_14-设计模式有哪些"><a href="#_14-设计模式有哪些" class="header-anchor">#</a> 14.设计模式有哪些</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>策略模式
<span class="token literal-property property">定义</span> <span class="token operator">:</span> 要实现某一个功能，有多种方案可以选择。我们定义策略，把它们一个个封装起来，并且使它们可以相互转换。
使用场景：
当你负责的模块，基本满足以下情况时
各判断条件下的策略相互独立且可复用
策略内部逻辑相对复杂
策略需要灵活组合
<span class="token number">2.</span>发布 <span class="token operator">-</span> 订阅模式
发布<span class="token operator">-</span>订阅是一种消息范式，消息的发布者，不会将消息直接发送给特定的订阅者，而是通过消息通道广播出去，然后呢，订阅者通过订阅获取到想要的消息
使用场景：
各模块相互独立
存在一对多的依赖关系
依赖模块不稳定、依赖关系不稳定
各模块由不同的人员、团队开发
<span class="token number">3.</span>装饰器模式
 是为了给一个函数赋能，增强它的某种能力，它能动态的添加对象的行为，也不影响原来的功能
<span class="token number">4.</span>适配器模式
个人理解，为了解决我们不兼容的问题，把一个类的接口换成我们想要的接口。
<span class="token number">5.</span>代理模式
代理模式是为其它对象提供一种代理以控制这个对象的访问，具体执行的功能还是这个对象本身
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="_15-mvvm是怎么实现的"><a href="#_15-mvvm是怎么实现的" class="header-anchor">#</a> 15.MVVM是怎么实现的</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">MVVM</span>的实现分为三步：数据劫持、模板编译和双向绑定
<span class="token number">1.</span>数据劫持  Object<span class="token punctuation">.</span>defineProperty方法，这也是vue2死活不支持ie8的原因之一
做数据劫持时主要用到的就是<span class="token keyword">get</span>和<span class="token keyword">set</span>两个属性，通过该方法被劫持的对象属性，只要在外界获取或者修改属性值都会触发<span class="token keyword">get</span>或<span class="token keyword">set</span>方法，这样我们就可以在<span class="token keyword">get</span>或<span class="token keyword">set</span>中对属性做一些额外对操作了
<span class="token number">2.</span>模板编译
在vue中是通过一些指令或者小胡子语法来实现数据绑定的，而浏览器并不认识这些指令或者小胡子语法，因此在页面加载后需要将这些语法转换成真正的数据呈现给用户 遍历#app下所有的节点，然后根据节点的类型做相应的操作
<span class="token number">3.</span>双向绑定
双向绑定 vue主要是利用数据劫持加发布订阅模式来实现数据的双向绑定的

首先我们需要定义一个Dep类，用于对属性进行依赖收集和通知用到属性到地方进行同步更新
然后再定义一个Watcher类，用于对属性进行监听，并实现属性值的同步更新
在模板编译的时候，通过watcher来监听属性
在数据劫持的<span class="token keyword">get</span>函数中进行依赖收集
在数据劫持的<span class="token keyword">set</span>函数中通知各个watcher进行数据更新
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_16-vue中组件通信方式"><a href="#_16-vue中组件通信方式" class="header-anchor">#</a> 16.vue中组件通信方式</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 父组件绑定属性传值 子组件props接收 子组件<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'事件'</span><span class="token punctuation">)</span>提交事件 父组件@事件      父子级传值
<span class="token number">2</span><span class="token punctuation">.</span>ref $refs 给子组件绑定ref属性，$refs可以获取子组件的属性和方法   父子级传值
<span class="token number">3.</span>父组件中 <span class="token keyword">this</span><span class="token punctuation">.</span>$children<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>msg获取子组件中的msg， 子组件中 <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>msg2 获取父组件中的msg2   父子级传值
<span class="token number">4</span><span class="token punctuation">.</span>Vuex  vue插件，创建一个store实例，state定义数据，mutation修改操作，action 异步任务，getter计算属性 
<span class="token number">5</span><span class="token punctuation">.</span>provide <span class="token operator">/</span> inject 通过provide：<span class="token punctuation">{</span><span class="token literal-property property">msg</span><span class="token operator">:</span><span class="token string">'我是父组件的数据'</span><span class="token punctuation">}</span> 与data同级 子组件中 ：inject<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'msg'</span><span class="token punctuation">]</span>与data同级，用的时候在data中data<span class="token operator">:</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">{</span><span class="token literal-property property">msg2</span><span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">}</span><span class="token punctuation">}</span> 不论子组件嵌套有多深<span class="token punctuation">,</span> 只要调用了inject 那么就可以注入provide中的数据，而不局限于只能从当前父组件的props属性中回去数据
<span class="token number">6</span><span class="token punctuation">.</span>eventBus 
<span class="token comment">// event-bus.js</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> EventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">7</span><span class="token punctuation">.</span>localStorage <span class="token operator">/</span> sessionStorage
<span class="token number">8</span><span class="token punctuation">.</span>$attrs 用途<span class="token operator">:</span>用来接受父组件传过来数据 <span class="token comment">//特征:父传子,没有被子组件props接收的属性放到$attrs里面 / </span>
$listeners <span class="token comment">//用途:用来接受父组件监听的事件方法 //特征:父组件通v-on监听事件,子组件通过$listeners接收事件方法</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_17-diff算法"><a href="#_17-diff算法" class="header-anchor">#</a> 17.diff算法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// diff算法  ==&gt; 比较新旧虚拟dom的差异</span>
<span class="token comment">// 策略1  ==&gt; 同级根元素的对比</span>
<span class="token comment">// 1. 如果根元素变化了，那么不考虑复用，整个dom树删除重建</span>
<span class="token comment">// 2. 如果根元素不变，看根元素的属性是否变化来更新属性，并递归的往下对比差异。</span>

<span class="token comment">// 策略2  ==&gt; 兄弟元素比较</span>
<span class="token comment">// 1. 对比同级兄弟元素，默认按照下标进行对比复用  （不加key或者说key为index的时候）</span>
<span class="token comment">// 2. 如果设置了key，key是唯一的标识，会按照相同的key的元素进行复用</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_18-vue-use原理"><a href="#_18-vue-use原理" class="header-anchor">#</a> 18.Vue.use原理</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// Vue.use 本身是一个函数，用来安装插件~~</span>
<span class="token comment">// Vue.use内部做了哪些操作？</span>
<span class="token comment">// 1. 判断插件是否注册安装过</span>
安装过直接<span class="token keyword">return</span> <span class="token keyword">this</span> 退出，方便下次链式调用
<span class="token comment">// 2. 如果这个要安装的插件本身有install方法，执行它</span>
<span class="token comment">//    同时把Vue构造函数作为第一个参数，以及use中的其他参数传入</span>
<span class="token comment">// 3. 如果没有install方法，并且插件本身就是一个函数，就去调用执行它</span>
<span class="token comment">//    同时把Vue构造函数作为第一个参数，以及use中的其他参数传入</span>
<span class="token comment">// 4. 记录这个插件已经注册过 添加到数组</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_19-为什么刷新页面vuex数据会丢失"><a href="#_19-为什么刷新页面vuex数据会丢失" class="header-anchor">#</a> 19.为什么刷新页面vuex数据会丢失</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>页面刷新的时候异步请求后台数据，然后动态更新vuex中的数据，其中会有一种情况就是，网络延迟、数据量大的问题。 此时还没等vuex获取到后台返回的数据，页面就已经加载完成了，这样就会造成数据丢失
<span class="token number">2.</span>因为store里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。
解决办法：<span class="token number">1.</span>使用本地存储 持久化数据
         <span class="token number">2.</span>使用插件 vuex<span class="token operator">-</span>persist
  使用步骤：
  <span class="token number">1</span><span class="token punctuation">.</span>npm install <span class="token operator">--</span>save vuex<span class="token operator">-</span>persist or yarn add vuex<span class="token operator">-</span>persist
  <span class="token number">2</span><span class="token punctuation">.</span>import VuexPersistence <span class="token keyword">from</span> <span class="token string">'vuex-persist'</span>  引入
  <span class="token number">3</span><span class="token punctuation">.</span>const vuexLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VuexPersistence</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">//  先创建一个对象并进行配置             </span>
    <span class="token literal-property property">storage</span><span class="token operator">:</span> window<span class="token punctuation">.</span>localStorage         
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token number">4</span><span class="token punctuation">.</span>const store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>       <span class="token comment">//引入vuex插件</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>vuexLocal<span class="token punctuation">.</span>plugin<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_20-vuex是干嘛的-属性怎么使用"><a href="#_20-vuex是干嘛的-属性怎么使用" class="header-anchor">#</a> 20.vuex是干嘛的，属性怎么使用</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Vuex是集中管理项目公共数据的
Vuex 有state、mutations 、getters、actions、module属性。 state 属性用来存储公共管理的数据。 mutations 属性定义改变state中数据的方法， 注意：不要在mutation中的方法中写异步方法ajax，那样数据就不可跟踪了 。 getters 属性可以认为是定义 store 的计算属性。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 action属性类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 moudle属性是将store分割成模块 <span class="token punctuation">,</span>可以通过map函数一次性获取多个属性或方法
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_21-vue2实现响应式的原理和缺陷"><a href="#_21-vue2实现响应式的原理和缺陷" class="header-anchor">#</a> 21.vue2实现响应式的原理和缺陷</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Vue响应式指的是：数据驱动视图，我们修改数据视图随之响应更新 核心<span class="token constant">API</span>：Object<span class="token punctuation">.</span>defineProperty
<span class="token number">1.</span>在我们执行<span class="token keyword">new</span> <span class="token class-name">Vue</span>创建实例时，会调用如下构造函数，在该函数内部调用<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span>
<span class="token number">2.</span><span class="token function">initMixin函数里面定义了原型方法_init，_init调用了initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>等方法，_init里做了很多初始化工作，我们重点关注initState
<span class="token number">3</span><span class="token punctuation">.</span>initState函数按顺序初始化$options的数据，顺序为 prop<span class="token operator">&gt;</span>methods<span class="token operator">&gt;</span>data<span class="token operator">&gt;</span>computed<span class="token operator">&gt;</span>watch
<span class="token number">4</span><span class="token punctuation">.</span>initData 将vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>data 赋值给vm<span class="token punctuation">.</span>_data 
<span class="token number">5.</span><span class="token function">proxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 把 data 里的每一个属性都代理到当前实例上，就可以通过 <span class="token keyword">this</span><span class="token punctuation">.</span>xx 访问了
<span class="token number">6.</span>然后再调用 observe 监听整个 data，该方法用于创建监听器实例 ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token number">7.</span>遍历对象所有属性，递归调用defineReactive 转为响应式对象，也是动态添加 getter 和 setter，实现双向绑定
<span class="token number">8.</span>在<span class="token keyword">get</span>中会收集属性的依赖，以及其属性值的依赖
<span class="token number">9.</span>当数据发生改变，会触发<span class="token keyword">set</span>函数，<span class="token keyword">set</span>通知视图更新
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_22-说一说-vue-的-keep-alive"><a href="#_22-说一说-vue-的-keep-alive" class="header-anchor">#</a> 22.说一说 vue 的 keep-alive ？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>作用：缓存组件，提升性能，避免重复加载一些不需要经常变动且内容较多的组件
keep<span class="token operator">-</span>alive属性 abstract<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span>
 当首次渲染的时候，会判断有没有这个属性，才会挂载到父组件上
keep<span class="token operator">-</span>alive 包裹动态组件时，会缓存不活动的组件实例
 <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>的使用方法：使用<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;keep-alive&gt;</span><span class="token template-punctuation string">`</span></span>标签对需要缓存的组件进行包裹， 
<span class="token comment">//被keep-alive包含的组件不会被再次初始化，也就意味着不会重走生命周期函数</span>
但是有时候是希望我们缓存的组件可以能够再次进行渲染，这时Vue为我们解决了这个问题
被包含在 keep<span class="token operator">-</span>alive 中创建的组件，会多出两个生命周期的钩子<span class="token operator">:</span> activated 与 deactivated：
activated 当 keep<span class="token operator">-</span>alive 包含的组件再次渲染的时候触发
deactivated 当 keep<span class="token operator">-</span>alive 包含的组件销毁的时候触发
keep<span class="token operator">-</span>alive可以接收<span class="token number">3</span><span class="token literal-property property">个属性做为参数进行匹配对应的组件进行缓存</span><span class="token operator">:</span>
<span class="token number">1.</span><span class="token function">include包含的组件</span><span class="token punctuation">(</span>可以为字符串，数组，以及正则表达式<span class="token punctuation">,</span>只有匹配的组件会被缓存<span class="token punctuation">)</span>
<span class="token number">2.</span><span class="token function">exclude排除的组件</span><span class="token punctuation">(</span>以为字符串，数组，以及正则表达式<span class="token punctuation">,</span>任何匹配的组件都不会被缓存<span class="token punctuation">)</span>
<span class="token number">3.</span><span class="token function">max缓存组件的最大值</span><span class="token punctuation">(</span>类型为字符或者数字<span class="token punctuation">,</span>可以控制缓存组件的个数<span class="token punctuation">)</span>
注：当使用正则表达式或者数组时，一定要使用v<span class="token operator">-</span>bind
<span class="token comment">//防坑指南</span>
<span class="token number">1</span><span class="token punctuation">.</span>keep<span class="token operator">-</span>alive 先匹配被包含组件的 name 字段，如果 name 不可用，则匹配当前组件 components 配置中的注册名称。
<span class="token number">2</span><span class="token punctuation">.</span>keep<span class="token operator">-</span>alive 不会在函数式组件中正常工作，因为它们没有缓存实例。
<span class="token number">3.</span>当匹配条件同时在 include 与 exclude 存在时，以 exclude <span class="token function">优先级最高</span><span class="token punctuation">(</span>当前vue <span class="token number">2.4</span><span class="token number">.2</span> version<span class="token punctuation">)</span>。比如：包含于排除同时匹配到了组件<span class="token constant">A</span>，那组件<span class="token constant">A</span>不会被缓存。
<span class="token number">4.</span>包含在 keep<span class="token operator">-</span>alive 中，但符合 exclude ，不会调用activated和 deactivated。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="_23-说一说vue-router-实现懒加载的方法"><a href="#_23-说一说vue-router-实现懒加载的方法" class="header-anchor">#</a> 23.说一说vue-router 实现懒加载的方法？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>vue<span class="token operator">-</span>router 实现懒加载的方法有两种： <span class="token constant">ES6</span><span class="token literal-property property">的impot方式</span><span class="token operator">:</span> <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="token string">'../views/About.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">VUE</span><span class="token literal-property property">中的异步组件进行懒加载方式</span><span class="token operator">:</span> <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">resolve</span><span class="token operator">=&gt;</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'../views/About'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>resolve<span class="token punctuation">)</span><span class="token punctuation">)</span> 加分回答 vue<span class="token operator">-</span>router 实现懒加载的作用：性能优化，不用到该路由，不加载该组件。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_24-说一说computed和watch的区别"><a href="#_24-说一说computed和watch的区别" class="header-anchor">#</a> 24.说一说computed和watch的区别？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；必须要有返回值 <span class="token punctuation">,</span>不支持异步，当Computed中有异步操作时，无法监听数据的变化，如果computed属性的属性值是函数，那么默认使用<span class="token keyword">get</span>方法，函数的返回值就是属性的属性值；在computed中，属性有一个<span class="token keyword">get</span>方法和一个<span class="token keyword">set</span>方法，当数据发生变化时，会调用<span class="token keyword">set</span>方法
<span class="token number">2.</span> watch： 更多的是观察的作用<span class="token punctuation">,</span><span class="token literal-property property">有两个属性，深度监听需要加deep</span><span class="token operator">:</span><span class="token boolean">true</span>，immediate：<span class="token boolean">true</span><span class="token punctuation">,</span>组件加载立即触发回调函数<span class="token punctuation">,</span>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值<span class="token punctuation">,</span>支持异步，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 
<span class="token number">3.</span>加分回答 computed应用场景：需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； watch应用场景：需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch <span class="token function">选项允许我们执行异步操作</span> <span class="token punctuation">(</span> 访问一个 <span class="token constant">API</span> <span class="token punctuation">)</span>，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_25-vue中刷新页面的方式有哪些"><a href="#_25-vue中刷新页面的方式有哪些" class="header-anchor">#</a> 25.vue中刷新页面的方式有哪些</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>原生js location<span class="token punctuation">.</span><span class="token function">reload</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  需要刷新的时候加这么一句代码，即可刷新
<span class="token number">2.</span>借助vue中的路由跳转方式， 在需要刷新的地方 写入 <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  因为是刷新当前页面，所以参数是<span class="token number">0</span>
<span class="token comment">//以上两种都是强制刷新，页面会出现短暂的空白</span>
<span class="token number">3.</span><span class="token function">provide</span><span class="token punctuation">(</span>po wai de<span class="token punctuation">)</span><span class="token operator">/</span>inject组合方式  <span class="token comment">//是普通刷新</span>
在父组件中定义一个布尔值变量，在定义一个刷新函数 <span class="token function">，刷新函数需要做的是，把布尔值取反，在确定取反之后</span><span class="token punctuation">(</span>加个<span class="token keyword">await</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>保证先取法<span class="token punctuation">)</span>，再一次取反，通过v<span class="token operator">-</span><span class="token keyword">if</span> 控制子组件的显示隐藏，当需要刷新的时候，子组件调用父组件中的刷新函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_26-说一下登录流程"><a href="#_26-说一下登录流程" class="header-anchor">#</a> 26.说一下登录流程</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 我们在登录页点击登录的时候<span class="token punctuation">,</span>前端会带着用户输入的用户名和密码，去调用后端的登录接口
<span class="token number">2.</span>后端收到请求会去验证用户名和密码，如果验证失败会返回错误信息，前端提示相应的错误信息，如果验证成功，后端就会给前端返回一个token
<span class="token number">3.</span>前端拿到token后，将token存储到 vuex和localStorage中，并跳转到相应的页面，并提示登录成功
<span class="token number">4.</span>前端每一次跳转到需要具备登录状态的页面时，都需要判断当前token是否存在，不存在则跳转到登录页，存在则正常跳转，通常把这个逻辑封装在路由守卫， router<span class="token punctuation">.</span><span class="token function">beforEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span>from<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> 路由前置守卫，另外在向后端发送其他请求时，需要在请求头中带上token，项目中我们一般把这一块的逻辑封装在请求拦截器中，后端判断请求头中有没有token，有则验证该token，验证成功就会正常的给我们返回数据，如果验证失败，比如token过期了，那么就会返回相应的错误码，前端拿到错误信息，清除token并回退至登录页
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_27-vue实例最后挂载到哪个标签上的"><a href="#_27-vue实例最后挂载到哪个标签上的" class="header-anchor">#</a> 27.vue实例最后挂载到哪个标签上的</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>vue实例最后会挂载在body标签里面，所以我们在vue中是获取不了body 标签的，如果要使用body标
签的话需要用原生的方式获取
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_28-token是什么-加密"><a href="#_28-token是什么-加密" class="header-anchor">#</a> 28.token是什么？（加密）</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> token也可以称做令牌，一般由 uid<span class="token operator">+</span>time<span class="token operator">+</span><span class="token function">sign</span><span class="token punctuation">(</span>签名<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">[</span>固定参数<span class="token punctuation">]</span> 组成
<span class="token literal-property property">uid</span><span class="token operator">:</span> 用户唯一身份标识
<span class="token literal-property property">time</span><span class="token operator">:</span> 当前时间的时间戳
<span class="token literal-property property">sign</span><span class="token operator">:</span> 签名<span class="token punctuation">,</span> 使用 hash<span class="token operator">/</span>encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接
<span class="token function">固定参数</span><span class="token punctuation">(</span>可选<span class="token punctuation">)</span><span class="token operator">:</span> 将一些常用的固定参数加入到 token 中是为了避免重复查库
<span class="token number">2.</span> token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据
库中
<span class="token number">3.</span> token 的认证流程
用户登录，成功后服务器返回Token给客户端。
客户端收到数据后保存在客户端
客户端再次访问服务器，将token放入headers中 或者每次的请求 参数中
服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码
<span class="token number">4.</span> token可以抵抗<span class="token constant">CSRF</span>，cookie<span class="token operator">+</span>session不行
<span class="token number">5.</span> session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会
面对负载均衡问题。负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享
session
<span class="token number">6.</span> 客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将
token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这
个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载
均衡多服务器的问题了。这个方法叫做<span class="token constant">JWT</span><span class="token punctuation">(</span>Json Web Token<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="_29-说一下双向数据绑定"><a href="#_29-说一下双向数据绑定" class="header-anchor">#</a> 29.说一下双向数据绑定</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// vue中  v-model 是一个语法糖</span>
      <span class="token parameter">作用：</span><span class="token operator">=&gt;</span> 将data中的数据和表单元素做一个双向绑定
      原理：针对不同的表单元素（或者说表单元素type的不同属性值），vue底层会让
        v<span class="token operator">-</span>model实现不同的属性绑定和事件监听 
 <span class="token number">1.</span> type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span>
      
      <span class="token number">1.1</span> <span class="token operator">:</span>value <span class="token operator">+</span> @input 

        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;msg&quot;</span><span class="token operator">&gt;</span>等价于
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;msg&quot;</span> @input<span class="token operator">=</span><span class="token string">&quot;handleInput&quot;</span><span class="token operator">&gt;</span>

      <span class="token number">1.2</span> <span class="token operator">:</span>value <span class="token operator">+</span> @change   <span class="token operator">==</span><span class="token operator">&gt;</span> v<span class="token operator">-</span>model<span class="token punctuation">.</span>lazy <span class="token parameter">相当于是触发回车或者失去焦点的时候触发</span> <span class="token operator">=&gt;</span> @change
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> v<span class="token operator">-</span>model<span class="token punctuation">.</span>laze<span class="token operator">=</span><span class="token string">&quot;msg&quot;</span><span class="token operator">&gt;</span>等价于
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;msg&quot;</span> @change<span class="token operator">=</span><span class="token string">&quot;handleInput&quot;</span><span class="token operator">&gt;</span>

      <span class="token number">2.</span> type<span class="token operator">=</span><span class="token string">&quot;checkbox&quot;</span>   <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token operator">:</span>checked <span class="token operator">+</span> @change 

        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;checkbox&quot;</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;flag&quot;</span><span class="token operator">&gt;</span>等价于
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;checkbox&quot;</span> <span class="token operator">:</span>checked<span class="token operator">=</span><span class="token string">&quot;flag&quot;</span> @change<span class="token operator">=</span><span class="token string">&quot;handleInput&quot;</span><span class="token operator">&gt;</span>
     <span class="token operator">--</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;msg&quot;</span><span class="token operator">&gt;</span>  而v<span class="token operator">-</span>mdel一句指令就搞定了 <span class="token operator">--</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;msg&quot;</span> @input<span class="token operator">=</span><span class="token string">&quot;hanldInput&quot;</span><span class="token operator">&gt;</span>


    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> msg2可以使用， e找不到<span class="token operator">--</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 模板中使用事件对象 如果监听的是dom元素事件 <span class="token parameter">$event</span> <span class="token operator">=&gt;</span> 事件对象  <span class="token operator">--</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;msg2&quot;</span> @input<span class="token operator">=</span><span class="token string">&quot;msg2 = $event.target.value&quot;</span><span class="token operator">&gt;</span> <span class="token operator">--</span><span class="token operator">&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="_30-vue自定义指令"><a href="#_30-vue自定义指令" class="header-anchor">#</a> 30.vue自定义指令</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'mymodel'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token comment">//只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span>
        <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">//被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中),需要父节点dom时使用这个钩子</span>
        <span class="token function">inserted</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">//所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</span>
        <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">//指令所在组件的 VNode **及其子 VNode** 全部更新后调用。</span>
        <span class="token function">componentUpdated</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        只调用一次，指令与元素解绑时调用。
        <span class="token function">unbind</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> oldVnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_31-vue中的computed和data里面的数据以及props可以同名吗"><a href="#_31-vue中的computed和data里面的数据以及props可以同名吗" class="header-anchor">#</a> 31.vue中的computed和data里面的数据以及props可以同名吗</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>不可以，因为computed和data以及props里面的数据最终会挂载到vue实例上，会被覆盖
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_32-vue中数组的哪些方法可以触发视图的更新-哪些不可以-有什么解决办法"><a href="#_32-vue中数组的哪些方法可以触发视图的更新-哪些不可以-有什么解决办法" class="header-anchor">#</a> 32.vue中数组的哪些方法可以触发视图的更新，哪些不可以，有什么解决办法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>可以触发视图更新的有
<span class="token number">1</span><span class="token punctuation">.</span>push <span class="token number">2</span><span class="token punctuation">.</span>pop <span class="token number">3</span><span class="token punctuation">.</span>shift <span class="token number">4</span><span class="token punctuation">.</span>unshift <span class="token number">5</span><span class="token punctuation">.</span>splice <span class="token number">6</span><span class="token punctuation">.</span>sort <span class="token number">7</span><span class="token punctuation">.</span>reverse <span class="token number">8</span><span class="token punctuation">.</span>filter <span class="token number">9</span><span class="token punctuation">.</span>slice <span class="token number">10</span><span class="token punctuation">.</span>concat
哪些不可以
<span class="token number">1.</span>利用索引直接设置一个数组项 <span class="token number">2.</span>直接修改数组的长度
vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义<span class="token punctuation">,</span>因为splice可以在数组的任何位置进行删除<span class="token operator">/</span>添加操作
解决办法 
可以用 <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">,</span>index<span class="token punctuation">,</span>newValue<span class="token punctuation">)</span>
对象的情况 ，vue中的Object<span class="token punctuation">.</span>defineProperty无法检测对象属性的添加或移除，无法监听到，
<span class="token literal-property property">解决办法</span><span class="token operator">:</span>全局的Vue<span class="token punctuation">.</span>set方法 （哪个对象，哪个属性，值）  <span class="token comment">// 等效于   vm.$set(vm.obj, 'b', 66)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_33-说一下路由的传参方式"><a href="#_33-说一下路由的传参方式" class="header-anchor">#</a> 33.说一下路由的传参方式</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// router  路由的全局最大的一个实例，唯一的</span>
<span class="token comment">// routes  路由规则列表 </span>
<span class="token comment">// route   一条路由规则</span>
<span class="token comment">// 传参的模式 </span>
 <span class="token number">1.</span> 查询参数
  <span class="token operator">&lt;</span>router<span class="token operator">-</span>link to<span class="token operator">=</span><span class="token string">&quot;/article?desc=美食&amp;city=重庆&quot;</span><span class="token operator">&gt;</span>
<span class="token comment">// 2. 动态路由的方式传参  ==&gt; 需要配置路由规则 </span>
<span class="token comment">// {path:'/user/:id', component:User}      在配置规则里面</span>
<span class="token comment">// &lt;router-link to=&quot;/user/007&quot;&gt;            </span>

 <span class="token number">2.</span> 接收
<span class="token comment">// query参数接收</span>
<span class="token comment">// this.$route.query.key</span>

<span class="token comment">// 动态路由接收</span>
<span class="token comment">// this.$route.params.key</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_34-说一下router模式"><a href="#_34-说一下router模式" class="header-anchor">#</a> 34.说一下router模式</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// 路由模式 两种</span>
    <span class="token comment">// 1. hash模式 ==&gt; # </span>
    <span class="token comment">// 2. history模式  ===&gt; /不带#号 </span>
    <span class="token comment">//  （如果改成了history模式，以后上下后端需要配置一些东西） </span>
    <span class="token comment">// 后端如果不会，把vue文档丢给他，来，我教你~~~ </span>

    <span class="token literal-property property">mode</span><span class="token operator">:</span><span class="token string">'history'</span><span class="token punctuation">,</span>  <span class="token comment">//设置路由模式 ，默认是hash</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="路由的按需加载"><a href="#路由的按需加载" class="header-anchor">#</a> 路由的按需加载</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候就可以用路由的懒加载，原理就是，当访问到某个页面的时候才加载对应的路由
webpack<span class="token operator">&lt;</span> <span class="token number">2.4</span> 时
<span class="token punctuation">{</span> 
    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/'</span><span class="token punctuation">,</span> 
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'home'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">components</span><span class="token operator">:</span><span class="token parameter">resolve</span><span class="token operator">=&gt;</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'@/components/home'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>resolve<span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
webpack<span class="token operator">&gt;</span> <span class="token number">2.4</span> 时
<span class="token punctuation">{</span> 
    <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/'</span><span class="token punctuation">,</span> 
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'home'</span><span class="token punctuation">,</span> 
    <span class="token function-variable function">components</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/components/home'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_35-说一下vue动态组件"><a href="#_35-说一下vue动态组件" class="header-anchor">#</a> 35.说一下vue动态组件</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>
      <span class="token function">动态组件的使用</span> <span class="token punctuation">(</span> component 组件 <span class="token operator">+</span> is 属性 <span class="token punctuation">)</span>
      <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 设置挂载点<span class="token operator">&lt;</span>component<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>在哪显示<span class="token punctuation">)</span>
      <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">使用is属性来设置要显示哪个组件</span> <span class="token punctuation">(</span>显示哪一个组件<span class="token punctuation">)</span>
    <span class="token operator">--</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>component <span class="token operator">:</span>is<span class="token operator">=</span><span class="token string">&quot;isShow&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">component&gt;  </span><span class="token regex-delimiter">/</span></span><span class="token operator">/</span><span class="token operator">/</span>jsShow 是个变量 ，是组件名
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token number">1.</span>动态组件：可以改变的组件
        <span class="token number">2.</span>解决问题：多个组件在同一位置，切换显示的需求 <span class="token operator">--</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_36-自定义指令"><a href="#_36-自定义指令" class="header-anchor">#</a> 36.自定义指令</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">// 局部注册，自定义命令</span>
  <span class="token literal-property property">directives</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">focus</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">//定义的时候不加v ，用的时候v-focus</span>
      <span class="token comment">//inserted===&gt;当指令所在的元素节点，被插入挂载到页面上的时候，触发这个函数,只会触发一次</span>
      <span class="token function">inserted</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//自己定义一些想要实现的逻辑</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
        el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

      <span class="token punctuation">}</span><span class="token punctuation">,</span>
          
   Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'color'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">inserted</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// (el , {value}) =&gt;对象的解构</span>
    el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> binding<span class="token punctuation">.</span>value
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// v-color=&quot;xxx&quot; ==&gt; binding.value </span>
  <span class="token comment">// update指令的值改变时触发, binding.value的值修改触发   局部注册指令的时候也可以用</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> binding<span class="token punctuation">.</span>value
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="_37-说一下vue中的插槽"><a href="#_37-说一下vue中的插槽" class="header-anchor">#</a> 37.说一下vue中的插槽</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>插槽分为默认插槽  插槽名字默认是<span class="token keyword">default</span> 如果只需要一个地方插入内容则
<span class="token number">2.</span>具名插槽   带有name属性的slot， 可以实现内容的定向分发  在slot标签上写上name属性，来决定放哪块内容 v<span class="token operator">-</span>slot可以简写为#
<span class="token number">3.</span>作用域插槽
<span class="token comment">// 作用域插槽：插槽可以携带参数，并且这些参数有访问的限制</span>
<span class="token comment">// 子组件插槽转过来的值，只能在对应的template模板中使用</span>
<span class="token comment">// 1. 给slot标签添加属性的方式，传参</span>
<span class="token comment">//  &lt;slot name=&quot;footer&quot; abc=&quot;abc&quot; msg=&quot;123&quot;&gt;&lt;/slot&gt;</span>
<span class="token comment">// 2. 所有被被添加的属性，都放到了一个对象中 slotProps 中</span>
<span class="token comment">//  {abc:'abc', msg:'123'}</span>
 slot插槽，作用：提前占位，将来写在父组件标签中间的那部分内容，就会替换这个标签 <span class="token operator">--</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> slot标签中也可以写默认的内容，只会在父组件使用时，没有提供内容的时候被渲染
原理：实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，虚拟dom存放在<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vm.$slot</span><span class="token template-punctuation string">`</span></span>中，默认插槽为<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vm.$slot.default</span><span class="token template-punctuation string">`</span></span>，具名插槽为<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">vm.$slot.xxx</span><span class="token template-punctuation string">`</span></span>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">$slot</span><span class="token template-punctuation string">`</span></span>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_38-说一下路由守卫"><a href="#_38-说一下路由守卫" class="header-anchor">#</a> 38.说一下路由守卫</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 一 全局守卫</span>
        <span class="token comment">// 1. 全局前置守卫 router.beforeEach((to,from,next)=&gt;{})</span>
        <span class="token comment">// 2. 全局解析守卫 router.beforeResolve()</span>
        <span class="token comment">// 3. 全局后置守卫 router.afterEach((to,from) =&gt;{})    ==&gt;它唯一没有next函数</span>
 <span class="token comment">// 二 路由独享守卫 router.beforeEnter </span>
        <span class="token comment">// 在配置路由的时候定义的守卫，只在进入当前路由之前触发 拦住</span>
<span class="token comment">// 三 组件内守卫  ==&gt; .vue文件中，配置的守卫，只对组件生效</span>
        <span class="token comment">// 1. router.beforeRouteEnter</span>
        <span class="token comment">// 2. router.beforeRouteUpdate </span>
        <span class="token comment">// 3. router.beforeRouteLeave</span>
<span class="token operator">/</span>  说明
 <span class="token comment">// 导航守卫 </span>
        <span class="token comment">// 全局守卫 3个  beforeEach / beforeResolve/ afterEach</span>
        <span class="token comment">// 路由独享守卫 1个  路由配置的时候定义的守卫  beforeEnter</span>
        <span class="token comment">// 组件内的时候 3个 beforeRouteEnter   ==&gt; 没有this   next(vm =&gt; {vm.msg})</span>
        <span class="token comment">//                beforeRouteUpdate  ==&gt; 动态路由切换，复用组件，如果想要重新请求数据</span>
        <span class="token comment">//                beforeRouteLeave   ==&gt; 在离开当前组件之前，询问一下，是否要离开呢</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_39-vue-的父子组件生命周期钩子函数执行顺序"><a href="#_39-vue-的父子组件生命周期钩子函数执行顺序" class="header-anchor">#</a> 39.Vue 的父子组件生命周期钩子函数执行顺序</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>加载渲染过程
父beforeCreate<span class="token operator">-</span><span class="token operator">&gt;</span>父created<span class="token operator">-</span><span class="token operator">&gt;</span>父beforeMount<span class="token operator">-</span><span class="token operator">&gt;</span>子beforeCreate<span class="token operator">-</span><span class="token operator">&gt;</span>子created<span class="token operator">-</span><span class="token operator">&gt;</span>子beforeMount<span class="token operator">-</span><span class="token operator">&gt;</span>子mounted<span class="token operator">-</span><span class="token operator">&gt;</span>父mounted
更新过程
父beforeUpdate<span class="token operator">-</span><span class="token operator">&gt;</span>子beforeUpdate<span class="token operator">-</span><span class="token operator">&gt;</span>子updated<span class="token operator">-</span><span class="token operator">&gt;</span>父updated
销毁过程
父beforeDestroy<span class="token operator">-</span><span class="token operator">&gt;</span>子beforeDestroy<span class="token operator">-</span><span class="token operator">&gt;</span>子destroyed<span class="token operator">-</span><span class="token operator">&gt;</span>父destroyed
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_40-当new-vue发生了什么"><a href="#_40-当new-vue发生了什么" class="header-anchor">#</a> 40.当new Vue发生了什么</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>Vue构造函数传入配置项options <span class="token punctuation">,</span>在Vue构造函数里调用<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_init在里面调用了initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>方法，初始化了我们配置项的一些东西，data props，methods，computed，watch，当判断配置项有data时， <span class="token function">执行initData</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>方法，在initData方法中
判断data是否是一个函数，如果是一个函数，就去调用这个函数，函数的返回值是一个对象，给vm<span class="token punctuation">.</span>_data 如果data不是一个函数，直接取data对象 取这个对象的所有属性 Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> 循环为每个属性调用 <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">_data</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>方法，proxy在内部将每个属性代理到了vm实例上，并设置<span class="token keyword">get</span> 和<span class="token keyword">set</span>方法 定义一个dep类，在<span class="token keyword">get</span>里收集依赖，数据发生改变，wacher通知视图更新
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_41-vue-loader是什么-使用它的用途有哪些"><a href="#_41-vue-loader是什么-使用它的用途有哪些" class="header-anchor">#</a> 41.vue-loader是什么？使用它的用途有哪些？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> Vue<span class="token operator">-</span>loader 会解析文件，提取出每个语言块 是vue文件的一个加载器，把template<span class="token operator">/</span>script<span class="token operator">/</span>style转换成js模块。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_42-常见的vue事件修饰符"><a href="#_42-常见的vue事件修饰符" class="header-anchor">#</a> 42.常见的vue事件修饰符</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">.</span>stop<span class="token operator">:</span>阻止冒泡
<span class="token punctuation">.</span>prevent<span class="token operator">:</span>阻止默认行为
<span class="token punctuation">.</span>self<span class="token operator">:</span>仅绑定元素自身触发
<span class="token punctuation">.</span>once<span class="token operator">:</span> <span class="token number">2.1</span><span class="token number">.4</span> 新增<span class="token punctuation">,</span>只触发一次
<span class="token punctuation">.</span>passive<span class="token operator">:</span> <span class="token number">2.3</span><span class="token number">.0</span> 新增<span class="token punctuation">,</span><span class="token function">滚动事件的默认行为</span> <span class="token punctuation">(</span>即滚动行为<span class="token punctuation">)</span> 将会立即触发<span class="token punctuation">,</span>不能和<span class="token punctuation">.</span>prevent 一起使用
<span class="token punctuation">.</span>sync 修饰符   自动更新父组件属性的 v<span class="token operator">-</span>on 监听器
<span class="token punctuation">.</span>native  让我们在子组件上定义的事件不在默认为是子组件提交的事件
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_43-ajax请求代码应该写在组件的methods中还是vuex的actions中"><a href="#_43-ajax请求代码应该写在组件的methods中还是vuex的actions中" class="header-anchor">#</a> 43.ajax请求代码应该写在组件的methods中还是vuex的actions中</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。
如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_44-vuex的严格模式是什么-有什么作用-怎么开启"><a href="#_44-vuex的严格模式是什么-有什么作用-怎么开启" class="header-anchor">#</a> 44.Vuex的严格模式是什么,有什么作用,怎么开启？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到
<span class="token comment">//开启方式</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">strict</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_45-mutation和action有什么区别"><a href="#_45-mutation和action有什么区别" class="header-anchor">#</a> 45.mutation和action有什么区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态
action 可以包含任意异步操作。mutation只能是同步操作
<span class="token number">2.</span> 提交方式不同
action 是用<span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'ACTION_NAME'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span>来提交。
mutation是用<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'SET_NUMBER'</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>来提交
<span class="token number">3.</span> 接收参数不同
接收参数不同，mutation第一个参数是state，而action第一个参数是context，
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_46-在v-model上怎么用vuex中state的值"><a href="#_46-在v-model上怎么用vuex中state的值" class="header-anchor">#</a> 46.在v-model上怎么用Vuex中state的值？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>需要通过computed计算属性来转换。
<span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;message&quot;</span><span class="token operator">&gt;</span>
<span class="token comment">// ...当然我们也可以引入map辅助函数</span>
    <span class="token keyword">import</span> <span class="token punctuation">{</span>mapState<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>
<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'message'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">//如何是模块里面的话，则需要加上模块名 ...mapState('user'['message'])</span>
    <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token function">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>message
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">set</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'updateMessage'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_47-vue里面router-link在电脑上有用-在安卓上没反应怎么解决"><a href="#_47-vue里面router-link在电脑上有用-在安卓上没反应怎么解决" class="header-anchor">#</a> 47.Vue里面router-link在电脑上有用，在安卓上没反应怎么解决</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_48-vue2中注册在router-link上事件无效解决方法"><a href="#_48-vue2中注册在router-link上事件无效解决方法" class="header-anchor">#</a> 48.Vue2中注册在router-link上事件无效解决方法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>使用@click<span class="token punctuation">.</span>native。原因：router<span class="token operator">-</span>link会阻止click事件，<span class="token punctuation">.</span>native指直接监听一个原生事件
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_49-vue中如何统一监听组件报错"><a href="#_49-vue中如何统一监听组件报错" class="header-anchor">#</a> 49.vue中如何统一监听组件报错</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>window<span class="token punctuation">.</span>onerror
可以监听当前页面所有的js报错，jquery时代经常使用，全局只绑定一次即可，不要放在多次渲染的组件中，这样容易多次绑定
window<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">msg<span class="token punctuation">,</span>source<span class="token punctuation">,</span>line</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_50-过滤器是什么-怎么实现"><a href="#_50-过滤器是什么-怎么实现" class="header-anchor">#</a> 50.过滤器是什么，怎么实现</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>根据过滤器的名称，过滤器是用来过滤数据的<span class="token punctuation">,</span><span class="token operator">-</span> 需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 <span class="token operator">/</span> 显示。
<span class="token operator">-</span> 比如后端返回一个 <span class="token operator">**</span>年月日的日期字符串<span class="token operator">**</span>，前端需要展示为 <span class="token operator">**</span>多少天前<span class="token operator">**</span> 的数据格式，此时就可以用<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">fliters</span><span class="token template-punctuation string">`</span></span>过滤器来处理数据。
过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在<span class="token operator">**</span>插值表达式<span class="token operator">**</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">**{{ }}**</span><span class="token template-punctuation string">`</span></span> 和 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">**v-bind**</span><span class="token template-punctuation string">`</span></span> <span class="token operator">**</span>表达式<span class="token operator">**</span> 中，然后放在操作符“ <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">**|**</span><span class="token template-punctuation string">`</span></span> ”后面进行指示。
<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>商品价格：<span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>price <span class="token operator">|</span> filterPrice<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
 <span class="token literal-property property">filters</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">filterPrice</span> <span class="token punctuation">(</span><span class="token parameter">price</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> price <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">'￥'</span> <span class="token operator">+</span> price<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">'--'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_51-说一下常见的事件修饰符"><a href="#_51-说一下常见的事件修饰符" class="header-anchor">#</a> 51.说一下常见的事件修饰符</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> <span class="token punctuation">.</span>stop：等同于 JavaScript 中的 event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ，防止事件冒泡；
<span class="token number">2.</span> <span class="token punctuation">.</span>prevent ：等同于 JavaScript 中的 event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；
<span class="token number">3.</span> <span class="token punctuation">.</span>capture ：与事件冒泡的方向相反，事件捕获由外到内；
<span class="token number">4.</span> <span class="token punctuation">.</span>self ：只会触发自己范围内的事件，不包含子元素；
<span class="token number">5.</span> <span class="token punctuation">.</span>once ：只会触发一次。
<span class="token number">6.</span><span class="token punctuation">.</span>native 个人理解就是，native最大的作用就是把组件上的事件不再认为是自定义的事件，而是原生的事件，原理是事件冒泡
<span class="token number">7.</span><span class="token punctuation">.</span>sync 当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_52-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决"><a href="#_52-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决" class="header-anchor">#</a> 52.Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>，obj<span class="token punctuation">.</span>b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj<span class="token punctuation">.</span>b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新<span class="token punctuation">,</span>当然这并不是Object<span class="token punctuation">.</span>defineProperty的缺陷，而是vue限制了，由玉溪说了是性能原因，性能代价和获得的用户体验收益不成正比，我下来也确实试了一下，
解决方法：
<span class="token function">addObjB</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'obj.b'</span><span class="token punctuation">)</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_53-vue-模板是如何编译的-经历了哪些过程"><a href="#_53-vue-模板是如何编译的-经历了哪些过程" class="header-anchor">#</a> 53.Vue 模板是如何编译的？经历了哪些过程？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Vue 模板在运行时会被编译成渲染函数，最终生成 Virtual <span class="token constant">DOM</span>，进行页面渲染。
Vue 模板编译的过程主要分为以下三个步骤：
<span class="token number">1.</span>解析模板：Vue 会使用正则表达式解析模板字符串，解析出其中的指令、标签、属性等内容。
<span class="token number">2.</span>生成 <span class="token constant">AST</span>（抽象语法树）：将解析后的模板字符串转化为抽象语法树，抽象语法树是一个以 JavaScript 对象表示的树形结构，它将模板中的各个节点和属性用 JavaScript 对象的形式表示出来，方便后续对模板进行分析和处理。
<span class="token number">3.</span>生成渲染函数：将 <span class="token constant">AST</span> 转化为渲染函数，渲染函数是一个纯 JavaScript 函数，用于将模板转化为 Virtual <span class="token constant">DOM</span>。
在模板的编译过程中，还会涉及到动态指令、插槽、组件等特殊情况的处理，不同的编译器实现可能存在一些差异，但大体的编译流程是相似的。
通过模板的编译，我们可以将模板转化为可被 JavaScript 运行的函数，从而更高效地渲染页面，提高应用的性能。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></div></div> <!----> <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/myblog/pages/21b7bd/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">js面试题大全</div></a> <a href="/myblog/pages/e2ab2a/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">vue3面试题大全</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/myblog/pages/21b7bd/" class="prev">js面试题大全</a></span> <span class="next"><a href="/myblog/pages/e2ab2a/">vue3面试题大全</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/myblog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/myblog/" class="router-link-active"><div>
            首页
            <!----></div></a> <span class="date"></span></dt></dl><dl><dd>02</dd> <dt><a href="/myblog/pages/2faf0d/"><div>
            vscode操作git
            <!----></div></a> <span class="date">07-10</span></dt></dl><dl><dd>03</dd> <dt><a href="/myblog/pages/e6d2d9/"><div>
            前端资料网站
            <!----></div></a> <span class="date">07-10</span></dt></dl> <dl><dd></dd> <dt><a href="/myblog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/myblog/assets/js/app.86e991b9.js" defer></script><script src="/myblog/assets/js/2.dd8fbd6f.js" defer></script><script src="/myblog/assets/js/35.d743471b.js" defer></script>
  </body>
</html>
