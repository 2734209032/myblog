<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js面试题 | hyh的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="stylesheet" href="/myblog/styles/custom.css">
    <meta name="description" content="页面的描述">
    
    <link rel="preload" href="/myblog/assets/css/0.styles.b7a98234.css" as="style"><link rel="preload" href="/myblog/assets/js/app.20d60f97.js" as="script"><link rel="preload" href="/myblog/assets/js/2.5c9bfcd5.js" as="script"><link rel="preload" href="/myblog/assets/js/17.c380dd16.js" as="script"><link rel="prefetch" href="/myblog/assets/js/10.396635fc.js"><link rel="prefetch" href="/myblog/assets/js/11.3f3cd1d4.js"><link rel="prefetch" href="/myblog/assets/js/12.facbbac8.js"><link rel="prefetch" href="/myblog/assets/js/13.be1bc3ee.js"><link rel="prefetch" href="/myblog/assets/js/14.93f9ec4c.js"><link rel="prefetch" href="/myblog/assets/js/15.972ca597.js"><link rel="prefetch" href="/myblog/assets/js/16.96c6402c.js"><link rel="prefetch" href="/myblog/assets/js/18.0329f85f.js"><link rel="prefetch" href="/myblog/assets/js/19.7a54f116.js"><link rel="prefetch" href="/myblog/assets/js/20.622eaebc.js"><link rel="prefetch" href="/myblog/assets/js/21.d13c3881.js"><link rel="prefetch" href="/myblog/assets/js/22.a1e4bbec.js"><link rel="prefetch" href="/myblog/assets/js/23.92aa9d3b.js"><link rel="prefetch" href="/myblog/assets/js/24.5de94bd2.js"><link rel="prefetch" href="/myblog/assets/js/25.ca98104b.js"><link rel="prefetch" href="/myblog/assets/js/26.1054efb3.js"><link rel="prefetch" href="/myblog/assets/js/27.72aa55cd.js"><link rel="prefetch" href="/myblog/assets/js/28.15e6ec4b.js"><link rel="prefetch" href="/myblog/assets/js/29.037ec09a.js"><link rel="prefetch" href="/myblog/assets/js/3.02e8bbf5.js"><link rel="prefetch" href="/myblog/assets/js/30.1dd7ed6e.js"><link rel="prefetch" href="/myblog/assets/js/31.ce9b66da.js"><link rel="prefetch" href="/myblog/assets/js/32.822bdf0c.js"><link rel="prefetch" href="/myblog/assets/js/33.a2a04065.js"><link rel="prefetch" href="/myblog/assets/js/34.b217471a.js"><link rel="prefetch" href="/myblog/assets/js/35.92f19e9b.js"><link rel="prefetch" href="/myblog/assets/js/36.f575944e.js"><link rel="prefetch" href="/myblog/assets/js/37.fa7ba34f.js"><link rel="prefetch" href="/myblog/assets/js/38.f85a42c1.js"><link rel="prefetch" href="/myblog/assets/js/39.396f79d6.js"><link rel="prefetch" href="/myblog/assets/js/4.ad53e12a.js"><link rel="prefetch" href="/myblog/assets/js/40.09ff1f80.js"><link rel="prefetch" href="/myblog/assets/js/41.ad06ce2d.js"><link rel="prefetch" href="/myblog/assets/js/42.a20dccc7.js"><link rel="prefetch" href="/myblog/assets/js/43.26998938.js"><link rel="prefetch" href="/myblog/assets/js/44.d8031636.js"><link rel="prefetch" href="/myblog/assets/js/45.3e8874d7.js"><link rel="prefetch" href="/myblog/assets/js/46.a551296e.js"><link rel="prefetch" href="/myblog/assets/js/47.e6e547b4.js"><link rel="prefetch" href="/myblog/assets/js/48.74882b99.js"><link rel="prefetch" href="/myblog/assets/js/49.3d2fc74c.js"><link rel="prefetch" href="/myblog/assets/js/5.ed4de7f6.js"><link rel="prefetch" href="/myblog/assets/js/50.56a23422.js"><link rel="prefetch" href="/myblog/assets/js/51.ed163c3c.js"><link rel="prefetch" href="/myblog/assets/js/52.9d1b615b.js"><link rel="prefetch" href="/myblog/assets/js/53.7c1287ae.js"><link rel="prefetch" href="/myblog/assets/js/54.f6482c62.js"><link rel="prefetch" href="/myblog/assets/js/55.5f1e4fbe.js"><link rel="prefetch" href="/myblog/assets/js/56.33cb7b6b.js"><link rel="prefetch" href="/myblog/assets/js/57.9d225d25.js"><link rel="prefetch" href="/myblog/assets/js/58.4f9665c8.js"><link rel="prefetch" href="/myblog/assets/js/59.80f8cc6b.js"><link rel="prefetch" href="/myblog/assets/js/6.08a51b40.js"><link rel="prefetch" href="/myblog/assets/js/60.08065889.js"><link rel="prefetch" href="/myblog/assets/js/61.f288f013.js"><link rel="prefetch" href="/myblog/assets/js/62.936926b0.js"><link rel="prefetch" href="/myblog/assets/js/63.d17fc059.js"><link rel="prefetch" href="/myblog/assets/js/64.6169d337.js"><link rel="prefetch" href="/myblog/assets/js/65.b50ced0c.js"><link rel="prefetch" href="/myblog/assets/js/66.2ccbcc98.js"><link rel="prefetch" href="/myblog/assets/js/67.8157d895.js"><link rel="prefetch" href="/myblog/assets/js/68.78696f04.js"><link rel="prefetch" href="/myblog/assets/js/69.eff0e18e.js"><link rel="prefetch" href="/myblog/assets/js/7.c837cdb8.js"><link rel="prefetch" href="/myblog/assets/js/70.21530e91.js"><link rel="prefetch" href="/myblog/assets/js/71.185eeac5.js"><link rel="prefetch" href="/myblog/assets/js/72.141cb02e.js"><link rel="prefetch" href="/myblog/assets/js/73.198fd4af.js"><link rel="prefetch" href="/myblog/assets/js/74.ffbe268e.js"><link rel="prefetch" href="/myblog/assets/js/75.ce112d77.js"><link rel="prefetch" href="/myblog/assets/js/76.6eda04b9.js"><link rel="prefetch" href="/myblog/assets/js/77.1dc6eb7c.js"><link rel="prefetch" href="/myblog/assets/js/78.09194743.js"><link rel="prefetch" href="/myblog/assets/js/79.aff2eda5.js"><link rel="prefetch" href="/myblog/assets/js/8.b2831f27.js"><link rel="prefetch" href="/myblog/assets/js/80.5743f85a.js"><link rel="prefetch" href="/myblog/assets/js/81.45739b30.js"><link rel="prefetch" href="/myblog/assets/js/82.0ec4722d.js"><link rel="prefetch" href="/myblog/assets/js/9.7809a3fa.js">
    <link rel="stylesheet" href="/myblog/assets/css/0.styles.b7a98234.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myblog/" class="home-link router-link-active"><!----> <span class="site-name">hyh的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myblog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端三剑客" class="dropdown-title"><!----> <span class="title" style="display:;">前端三剑客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/javascript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/myblog/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/myblog/JavaScript/" class="nav-link">JavaScript</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/myblog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端三剑客" class="dropdown-title"><!----> <span class="title" style="display:;">前端三剑客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/javascript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/myblog/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/myblog/JavaScript/" class="nav-link">JavaScript</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/myblog/" aria-current="page" class="sidebar-link">博客简介</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>面试篇</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/pages/6cbb94/" class="sidebar-link">html面试题大全</a></li><li><a href="/myblog/pages/828be1/" class="sidebar-link">css面试题大全</a></li><li><a href="/myblog/pages/21b7bd/" aria-current="page" class="active sidebar-link">js面试题大全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_1-什么是bfc" class="sidebar-link">1.什么是BFC</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_2-统计字符串中的字符出现次数" class="sidebar-link">2.统计字符串中的字符出现次数</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_3-扁平数组" class="sidebar-link">3.扁平数组</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_4-typeof-和instanceof的区别" class="sidebar-link">4.typeof 和instanceof的区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_5-检测数据类型的几种方式" class="sidebar-link">5.检测数据类型的几种方式</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_6-事件对象需要记住两个方法" class="sidebar-link">6.  事件对象需要记住两个方法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_7-this" class="sidebar-link">7. this</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_8-事件流" class="sidebar-link">8.事件流</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_9-事件委托" class="sidebar-link">9.事件委托</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_10-页面加载事件的区别" class="sidebar-link">10.页面加载事件的区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_11-页面滑动效果" class="sidebar-link">11.页面滑动效果</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_12-立即执行函数的优点" class="sidebar-link">12.立即执行函数的优点</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_13-构造函数实例化对象-原型的考点" class="sidebar-link">13.构造函数实例化对象 原型的考点</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_14-本地储存考点" class="sidebar-link">14.本地储存考点</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_15-js-执行机制" class="sidebar-link">15.js 执行机制</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_16-作用域" class="sidebar-link">16.作用域</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_17-var-let-const-区别" class="sidebar-link">17.var let const 区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_18-作用域链" class="sidebar-link">18.作用域链</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_19-垃圾回收机制" class="sidebar-link">19.垃圾回收机制</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_20-闭包" class="sidebar-link">20.闭包</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_21-函数相关面试" class="sidebar-link">21.函数相关面试</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_22-箭头函数考点" class="sidebar-link">22.箭头函数考点</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_23-浅拷贝" class="sidebar-link">23.浅拷贝</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_24-深拷贝" class="sidebar-link">24.深拷贝</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_25-js实现继承的方式" class="sidebar-link">25. js实现继承的方式</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_26-call-aplly-bind-面试题" class="sidebar-link">26.call aplly bind 面试题</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_27-防抖" class="sidebar-link">27.防抖</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_28-节流" class="sidebar-link">28.节流</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_29-lodash防抖节流" class="sidebar-link">29.lodash防抖节流</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_30-extends继承" class="sidebar-link">30.extends继承</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_31-super-继承" class="sidebar-link">31.super 继承</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_32-事件循环" class="sidebar-link">32.事件循环</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_33-宏任务-微任务" class="sidebar-link">33.宏任务 微任务</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_34-this是如何工作的" class="sidebar-link">34.this是如何工作的</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_35-js模块化" class="sidebar-link">35.js模块化</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_36-说说匿名函数" class="sidebar-link">36.说说匿名函数</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_37-说说立即执行函数" class="sidebar-link">37.说说立即执行函数</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_38-说说函数柯里化" class="sidebar-link">38.说说函数柯里化</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_39-如何判断一个变量是不是数组" class="sidebar-link">39.如何判断一个变量是不是数组</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_40-原始值类型包装" class="sidebar-link">40.原始值类型包装</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_41-和-的区别以及扩展es6方法" class="sidebar-link">41.==和===的区别以及扩展es6方法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_42-同源策略" class="sidebar-link">42.同源策略</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_43-null和undefined的区别" class="sidebar-link">43.null和undefined的区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_44-说一下内存泄漏" class="sidebar-link">44.说一下内存泄漏</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_45-说一下script标签中的defer-和async属性" class="sidebar-link">45.说一下script标签中的defer 和async属性</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_46-说一下-web-worker" class="sidebar-link">46.说一下 web worker</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_47-说一下什么是可变对象什么是不可变对象" class="sidebar-link">47.说一下什么是可变对象什么是不可变对象</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_48-set-和-map有什么区别" class="sidebar-link">48.Set 和 Map有什么区别？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_49-如何将类数组转化为真数组" class="sidebar-link">49.如何将类数组转化为真数组</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_50-为什么js是单线程" class="sidebar-link">50.为什么js是单线程</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_51-说说promise的all和race" class="sidebar-link">51.说说promise的all和race</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_52-立即执行函数面试题" class="sidebar-link">52.立即执行函数面试题</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_53-说说for-in-和for-of区别" class="sidebar-link">53.说说for in 和for of区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_54-为什么推荐把script标签放到body底部" class="sidebar-link">54.为什么推荐把script标签放到body底部</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_55-说一下原生js怎么获取dom元素" class="sidebar-link">55.说一下原生js怎么获取dom元素</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_56-说一下es6新特性" class="sidebar-link">56.说一下es6新特性</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_57-object-assign" class="sidebar-link">57.Object.assign()</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_58-break-return-continue的区别" class="sidebar-link">58.break return continue的区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_59-为什么-0-1-0-2-0-3" class="sidebar-link">59.为什么 0.1+0.2!=0.3</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_60-数组里面有2w个元素-取第一个元素和最后一个元素的时间相差多少" class="sidebar-link">60.数组里面有2w个元素，取第一个元素和最后一个元素的时间相差多少？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_61-es6-代码转成-es5-代码的实现思路是什么" class="sidebar-link">61.ES6 代码转成 ES5 代码的实现思路是什么？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_62-dom和bom区别-以及常用方法" class="sidebar-link">62.DOM和BOM区别，以及常用方法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_63-说一下es6的新特性" class="sidebar-link">63.说一下es6的新特性</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_64-super-继承" class="sidebar-link">64.super 继承</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_65-说一下promise是什么以及使用方法" class="sidebar-link">65.说一下promise是什么以及使用方法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_66-js实现异步的方法" class="sidebar-link">66.js实现异步的方法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_67-数组去重的方法" class="sidebar-link">67.数组去重的方法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_68-说一下js-变量提升" class="sidebar-link">68.说一下js 变量提升</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_69-map和foreach的区别" class="sidebar-link">69.map和forEach的区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_70-说一下fetch-请求方式" class="sidebar-link">70.说一下fetch 请求方式？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_80-说一下js数据类型的隐式转换呢" class="sidebar-link">80.说一下js数据类型的隐式转换呢</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_81-并发与并行的区别" class="sidebar-link">81.并发与并行的区别？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_82-多维数组降维的方法" class="sidebar-link">82.多维数组降维的方法</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_83-如何合并对个数组-对象" class="sidebar-link">83.如何合并对个数组，对象？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_84-知道lodash吗-它有哪些常见的api" class="sidebar-link">84.知道lodash吗？它有哪些常见的API ？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_85-知道symbol-吗" class="sidebar-link">85.知道symbol 吗？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_86-请描述一下es6中的class类" class="sidebar-link">86.请描述一下ES6中的class类?</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_87-cookie和session-的区别" class="sidebar-link">87.cookie和session 的区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_88-如何获取数组中最后一个元素" class="sidebar-link">88.如何获取数组中最后一个元素</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_89-说一下echarts使用的基本步骤" class="sidebar-link">89.说一下echarts使用的基本步骤</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_90-为什么会有bigint提案" class="sidebar-link">90.为什么会有Bigint提案</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_91-javascript脚本延迟加载的方式有哪些" class="sidebar-link">91.JavaScript脚本延迟加载的方式有哪些？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_92-什么是尾调用-使用尾调用有什么好处" class="sidebar-link">92.什么是尾调用，使用尾调用有什么好处？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_93-es6-module和commonjs模块的区别" class="sidebar-link">93.ES6 Module和CommonJS模块的区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_94-介绍一下-js-中-settimeout-的运行机制" class="sidebar-link">94.介绍一下 JS 中 setTimeout 的运行机制？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_95-js-如何顺序执行-10-个异步任务" class="sidebar-link">95.JS 如何顺序执行 10 个异步任务？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_96-map-和-weakmap-的区别" class="sidebar-link">96.Map 和 WeakMap 的区别</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/21b7bd/#_97-typeof不能判断数组-如何加一个条件达到我们判断的要求" class="sidebar-link">97.typeof不能判断数组，如何加一个条件达到我们判断的要求</a></li></ul></li><li><a href="/myblog/pages/307985/" class="sidebar-link">vue2面试题大全</a></li><li><a href="/myblog/pages/e2ab2a/" class="sidebar-link">vue3面试题大全</a></li><li><a href="/myblog/pages/a1fd8f/" class="sidebar-link">浏览器面试题大全</a></li><li><a href="/myblog/pages/ceafae/" class="sidebar-link">性能优化</a></li><li><a href="/myblog/pages/291559/" class="sidebar-link">个人面试经历</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>es6基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ajax基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>git基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue2基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue3基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>lodash基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器基础篇</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/myblog/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/myblog/categories/?category=blogs" title="分类" data-v-06225672>blogs</a></li><li data-v-06225672><a href="/myblog/categories/?category=JavaScript" title="分类" data-v-06225672>JavaScript</a></li></ul> <div class="info" data-v-06225672><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-07-04</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">js面试题<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="_1-什么是bfc"><a href="#_1-什么是bfc" class="header-anchor">#</a> 1.什么是BFC</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">BFC</span>叫块级格式化上下文
<span class="token constant">BFC</span>是一个完全独立的空间（布局环境），块级格式化上下文，它是指一个独立的块级渲染区域<span class="token punctuation">,</span>让空间里的子元素不会影响到外面的布局。那么怎么使用<span class="token constant">BFC</span>呢，<span class="token constant">BFC</span>可以看做是一个<span class="token constant">CSS</span>元素属性

<span class="token constant">BFC</span>的方式都能清除浮动，但是常使用的清除浮动的<span class="token constant">BFC</span>方式只有<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">overflow:hidden</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>原因是使用float或者position方式清除浮动，虽然父级盒子内部浮动被清除了，但是父级本身又脱离文档流了，会对父级后面的兄弟盒子的布局造成影响。如果设置父级为<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">display:flex</span><span class="token template-punctuation string">`</span></span>，内部的浮动就会失效。所以通常只是用<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">overflow: hidden</span><span class="token template-punctuation string">`</span></span>清除浮动
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>触发条件</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>这里简单列举几个触发<span class="token constant">BFC</span>使用的<span class="token constant">CSS</span>属性
<span class="token number">1.</span> <span class="token literal-property property">overflow</span><span class="token operator">:</span> hidden    <span class="token comment">//清除浮动，本质就是触发了BFC</span>
<span class="token number">2.</span> <span class="token literal-property property">display</span><span class="token operator">:</span> inline<span class="token operator">-</span>block
<span class="token number">3.</span> <span class="token literal-property property">position</span><span class="token operator">:</span> absolute
<span class="token number">4.</span> <span class="token literal-property property">position</span><span class="token operator">:</span> fixed
<span class="token number">5.</span> <span class="token literal-property property">display</span><span class="token operator">:</span> table<span class="token operator">-</span>cell
<span class="token number">6.</span> <span class="token literal-property property">display</span><span class="token operator">:</span> flex
<span class="token number">7</span><span class="token punctuation">.</span>float的值不是none
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>应用场景</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 应用场景：</span>
<span class="token comment">// 1. 防止外边距塌陷</span>
<span class="token comment">// 2. 清浮动，（包含浮动元素），计算BFC高度的时候，浮动的子元素也会参与计算。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_2-统计字符串中的字符出现次数"><a href="#_2-统计字符串中的字符出现次数" class="header-anchor">#</a> 2.统计字符串中的字符出现次数</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">// 1.let str = 'ashdkahsfukaysduiqewke'</span>
    <span class="token comment">// 现在有一段字符串，要求统计字符串种出现的字符和次数</span>
    <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'ashdkahsfukaysduiqewke'</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      key <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">++</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">else</span> <span class="token punctuation">{</span>
        obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_3-扁平数组"><a href="#_3-扁平数组" class="header-anchor">#</a> 3.扁平数组</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token comment">// let arr = [1, 2, 3, [4, 5, [6, 7, [8, 9]]]]，将数组arr转变成[1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> newarr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> newarr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">fn</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> newarr<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
          newarr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">fn</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> newarr<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newarr<span class="token punctuation">)</span>
arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span> <span class="token comment">//直接可以把多维数组变成一个数组</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_4-typeof-和instanceof的区别"><a href="#_4-typeof-和instanceof的区别" class="header-anchor">#</a> 4.typeof 和instanceof的区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>相同点：都是用来检测数据类型的
不同点：
<span class="token number">1</span><span class="token punctuation">.</span>typeof<span class="token operator">:</span>只能检测简单数据类型除了<span class="token keyword">null</span>以外，不能检测复杂数据类型，除了<span class="token keyword">function</span>以外，且返回的是数据类型的字符串
<span class="token number">2</span><span class="token punctuation">.</span>instanceof：检测复杂数据类型 ，不能检测简单数据类型，返回的是布尔值，原理 ：而<span class="token keyword">instanceof</span>还可以用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上，返回布尔值
之所以 arr <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> 为<span class="token boolean">true</span>  <span class="token class-name">就是因为Object</span><span class="token punctuation">.</span>prototype出现在arr的原型上
<span class="token keyword">typeof</span> 原理：js 在底层存储变量的时候，会在变量的机器码的低位<span class="token number">1</span><span class="token operator">-</span><span class="token number">3</span>位存储其类型信息  
<span class="token number">000</span>：对象
<span class="token number">010</span>：浮点数
<span class="token number">100</span>：字符串
<span class="token number">110</span>：布尔
<span class="token number">1</span>：整数
对于 <span class="token keyword">undefined</span> 和 <span class="token keyword">null</span> 来说，这两个值的信息存储是有点特殊的。
<span class="token keyword">null</span>：所有机器码均为<span class="token number">0</span>
<span class="token keyword">undefined</span>：用 −<span class="token number">2</span><span class="token operator">^</span><span class="token number">30</span> 整数来表示
所以，<span class="token keyword">typeof</span> 在判断 <span class="token keyword">null</span> 的时候就出现问题了，由于 <span class="token keyword">null</span> 的所有机器码均为<span class="token number">0</span>，因此直接被当做了对象来看待。
<span class="token keyword">null</span> 其实属于自己的类型 Null，而不属于Object类型，<span class="token keyword">typeof</span> 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 <span class="token number">0</span> 会被 <span class="token keyword">typeof</span> 判断为对象类型，而 <span class="token keyword">null</span> 的二进制位恰好都是 <span class="token number">0</span> ，因此，<span class="token keyword">null</span> 被误判断为 Object 类型
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_5-检测数据类型的几种方式"><a href="#_5-检测数据类型的几种方式" class="header-anchor">#</a> 5.检测数据类型的几种方式</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>基本数据类型：Number String Boolean <span class="token operator">/</span> <span class="token keyword">undefined</span> <span class="token keyword">null</span> <span class="token operator">/</span> Symbol BigInt 
Symbol是<span class="token constant">ES6</span>新出的一种数据类型，这种数据类型的特点就是没有重复的数据，可以作为object的key。
    <span class="token comment">// 引用类型：Object ==&gt;  Function Array Date Math RegExp</span>
<span class="token number">1.</span> <span class="token keyword">typeof</span>    缺陷：只能检测简单数据类型，检测复杂类型不准确 ege <span class="token keyword">typeof</span> arr  <span class="token comment">//Object</span>
<span class="token number">2.</span> <span class="token keyword">instanceof</span> 缺陷：检测复杂数据类型，还可以用于检测构造函数的prototype 属性是否出现在某个实例对象的原型链上
<span class="token number">3.</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  最完美的检测数据类型的方式
<span class="token number">4.</span>正则
<span class="token number">5</span><span class="token punctuation">.</span>constructor
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><hr> <h2 id="_6-事件对象需要记住两个方法"><a href="#_6-事件对象需要记住两个方法" class="header-anchor">#</a> 6.  事件对象需要记住两个方法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  阻止事件冒泡 

<span class="token number">2.</span> e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   阻止默认行为 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_7-this"><a href="#_7-this" class="header-anchor">#</a> 7. this</h2> <p><code>this 就是一个变量，值是一个对象， 程序运行时内部自动生成的，代表着当前的运行环境</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>普通函数调用 ：<span class="token keyword">this</span>指向调用者，
定时器中的回调函数指向的是window
事件绑定中的回调函数指向 事件源
对象中的方法调用指向对象本身
构造函数里面的<span class="token keyword">this</span>指向实例
prototype上的方法指向实例
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_8-事件流"><a href="#_8-事件流" class="header-anchor">#</a> 8.事件流</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 事件流： 事件执行过程中的流动路径。    // 事件流描述的是元素在页面中接收事件的顺序。</span>
事件流有三个阶段 <span class="token number">1.</span>捕获阶段 <span class="token number">2.</span>当前目标阶段 <span class="token number">3.</span>冒泡阶段    
<span class="token comment">// div.addEventListener(type, listener, useCapture);   </span>
<span class="token comment">// 1. type 事件类型  </span>
<span class="token comment">// 2. listener 回调函数  </span>
<span class="token comment">// 3. useCapture 是否使用捕获 如果使用，传true, 否则 false (如果这个参数不传，默认是false)不传参 默认就是冒泡   `` 阻止冒泡 e.stopPropagation()`  `` 阻止默认行为  e.preventDefault()`</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_9-事件委托"><a href="#_9-事件委托" class="header-anchor">#</a> 9.事件委托</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">事件委托的原理</span><span class="token operator">:</span>利用事件冒泡，我们给父元素绑定事件，当点击了子元素冒泡到父元素上，父元素有事件，触发事件
<span class="token operator">==</span><span class="token operator">&gt;</span> 触发事件的元素e <span class="token punctuation">.</span>target<span class="token operator">==</span><span class="token operator">&gt;</span> 绑定事件的元素
<span class="token keyword">this</span>
e<span class="token punctuation">.</span>currentTarget <span class="token operator">==</span><span class="token operator">&gt;</span> 绑定事件的元素
<span class="token operator">/</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>tagName <span class="token operator">===</span> <span class="token function">标签名</span> <span class="token punctuation">(</span>大写<span class="token punctuation">)</span> 用它来判断点击的是否是某些标签
也可以用e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>className<span class="token operator">===</span><span class="token string">'类名'</span> 来判断是否点击的某些标签
  事件委托的好处： 减少注册事件的次数 提高程序的性能
   缺点：
   <span class="token number">1.</span>事件委托给予冒泡<span class="token punctuation">,</span>对于不冒泡的事件不支持<span class="token punctuation">.</span>
   <span class="token number">2.</span>层级过多<span class="token punctuation">,</span>冒泡过程中<span class="token punctuation">,</span>可能会被某层阻止掉
   <span class="token number">3.</span>理论上委托会导致浏览器频繁调用处理函数<span class="token punctuation">,</span>虽然很可能不需要处理<span class="token punctuation">,</span>所以建议就近委托<span class="token punctuation">,</span>比如在table上代理id<span class="token punctuation">,</span> 而不是在doncument上代理td
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><hr> <h2 id="_10-页面加载事件的区别"><a href="#_10-页面加载事件的区别" class="header-anchor">#</a> 10.页面加载事件的区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>            <span class="token comment">//当页面的所有资源包括外联的资源全部加载完毕，再执行里面的代码</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">2</span><span class="token punctuation">.</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> fn<span class="token punctuation">)</span>
             <span class="token comment">//仅当DOM元素加载完成，执行里面的代码</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_11-页面滑动效果"><a href="#_11-页面滑动效果" class="header-anchor">#</a> 11.页面滑动效果</h2> <p>就是做返回顶部，让画面带点动画效果</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token comment">/* 让页面是滑动的效果 */</span>
<span class="token selector">html</span> <span class="token punctuation">{</span>
  <span class="token property">scroll-behavior</span><span class="token punctuation">:</span> smooth<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*滤镜*/</span>
 <span class="token selector">html</span> <span class="token punctuation">{</span>
    <span class="token comment">/* filter: blur(10px);      变模糊 */</span>
    <span class="token comment">/* filter: saturate(1)      饱和度*/</span>
    <span class="token comment">/* filter: grayscale(1);       全页面变灰色 */</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><hr> <h2 id="_12-立即执行函数的优点"><a href="#_12-立即执行函数的优点" class="header-anchor">#</a> 12.立即执行函数的优点</h2> <p><code>立即执行函数的作用 ： 创建一个独立的作用域，防止变量名冲突，避免变量污染立即执行函数中的this指向window没有事件对象</code></p> <h2 id="_13-构造函数实例化对象-原型的考点"><a href="#_13-构造函数实例化对象-原型的考点" class="header-anchor">#</a> 13.构造函数实例化对象 原型的考点</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">// 实例化： 通过构造函数创建对象的过程就叫做实例化</span>
  <span class="token comment">// 实例： 实际的例子，具体的某一个对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>  构造函数名字首字母一般要大写（为了从视觉上区分构造函数和普通函数）

<span class="token number">2.</span>  构造函数里 属性和方法前面必须添加 <span class="token keyword">this</span>

  <span class="token number">3.</span>  构造函数不需要 <span class="token keyword">return</span> 就可以返回结果（构造函数的返回值即为新创建的对象）

<span class="token number">4.</span>  我们调用构造函数 必须使用 <span class="token keyword">new</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>new的执行过程</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">new</span> 执行过程 当我们执行<span class="token keyword">new</span>的时候，会去执行构造函数里面的代码

 <span class="token keyword">new</span>的执行过程？

<span class="token number">1.</span>首先会创建一个空对象 obj
<span class="token number">2.</span>给这个obj对象加__proto__属性，链接构造函数的prototype
<span class="token number">3.</span><span class="token function">构造函数调用call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法 参数是创建的对象，让当前构造函数的执行上下文中的<span class="token keyword">this</span>环境指向这个对象
<span class="token number">4.</span>执行构造函数里面的代码
<span class="token number">6.</span>判断构造函数中有没有<span class="token keyword">return</span> 有<span class="token keyword">return</span>的话，返回<span class="token keyword">return</span>后面的
<span class="token number">5.</span>没有<span class="token keyword">return</span> 返回这个新创建的对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><hr> <p><strong>2.原型的五大规则</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 语法糖</span>
<span class="token comment">// const obj = {}   ===&gt;  const obj = new Object()</span>
<span class="token comment">// const arr = []      ===&gt;  const arr = new Array()</span>

 <span class="token number">1.</span> 所有的引用类型（数组对象函数），都具有对象的特性，可以自由的扩展属性。
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment">// obj.a = 1 </span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment">// arr.b = 2</span>
<span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment">// fn.c = 3</span>

 <span class="token number">2.</span> 所有的对象，都有一个__proto__属性，属性值是一个普通的对象。 （__proto__ 隐式原型）
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span>

 <span class="token number">3.</span> <span class="token function">所有的函数，都有一个prototype属性，属性值也是一个普通的对象</span>  <span class="token punctuation">(</span>prototype 显示原型<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>   

 <span class="token number">4.</span> 所有对象的隐式原型（__proto__） 指向它的构造函数的显示原型（prototype）
obj<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype
arr<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
fn<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype

 <span class="token number">5.</span> 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__中寻找
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p><strong>构造函数 实例 原型对象 关系</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 当<span class="token keyword">new</span>时，构造函数实例化了对象
<span class="token number">2.</span> 构造函数中的prototype属性指向原型对象
<span class="token number">3.</span> 原型对象里面有constructor属性指回构造函数
<span class="token number">4.</span> <span class="token function">实例中的隐式原型</span><span class="token punctuation">(</span>__proto_<span class="token punctuation">)</span>指向构造函数的原型对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>实例成员和静态成员</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span><span class="token function">实例成员：在实例上</span><span class="token punctuation">(</span>对象<span class="token punctuation">)</span>的属性和方法叫实例成员，只能实例自己访问，构造函数访问不了

<span class="token number">2.</span>静态成员：在构造函数本身的属性和方法叫静态成员，只能构造函数本身访问  静态成员中的<span class="token keyword">this</span>指向构造函数本身
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>1.原型</strong></p> <p><strong>什么是原型</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 每个函数都有prototype属性，它的值是一个指针，指向的就是原型对象
<span class="token number">2.</span> 通过构造函数生成的实例，都有一个__proto__属性，也指向原型对象
<span class="token number">3.</span> 原型对象上默认有一个constructor属性，指回构造函数

<span class="token operator">**</span>原型的作用<span class="token operator">**</span>

<span class="token number">1.</span> 我们可以把一些公共的属性和方法放到原型上
<span class="token number">2.</span> 通过构造函数创建的实例，都共享原型上的属性和方法
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>2.原型链</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>每个对象通过__proto__都能访问到它的原型，原型也有它的原型

当访问一个对象的属性和方法时，先在自身上寻找

 如果没有的话，就会沿着__proto__ <span class="token class-name">这条链，向上查找，一直找到最顶层Object</span><span class="token punctuation">.</span>prototype为止
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_14-本地储存考点"><a href="#_14-本地储存考点" class="header-anchor">#</a> 14.本地储存考点</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>面试题 如果问 localStorage 和 sessionStorage 、cookie 的区别？
得分点 数据存储位置、生命周期、存储大小、写入方式、数据共享、发送请求时是否携带、应用场景 标准回答
Cookie、SessionStorage、 LocalStorage都是浏览器的本地存储。 它们的共同点：都是存储在浏览器本地的 它们的区别：cookie是由服务器端写入的，而SessionStorage、 LocalStorage都是由前端写入的，cookie的生命周期是由服务器端在写入的时候就设置好的，LocalStorage是写入就一直存在，除非手动清除或卸载浏览器，SessionStorage是页面关闭的时候就会自动清除。cookie的存储空间比较小大概4KB，SessionStorage、 LocalStorage存储空间比较大，大概5M。Cookie、SessionStorage、 LocalStorage数据共享都遵循同源原则，SessionStorage还限制必须是同一个页面。在前端给后端发送请求的时候会自动携带Cookie中的数据，但是SessionStorage、 LocalStorage不会 加分回答 <span class="token function">由于它们的以上区别，所以它们的应用场景也不同，Cookie一般用于存储登录验证信息SessionID或者token，LocalStorage常用于存储不易变动的数据，减轻服务器的压力，SessionStorage可以用来检测用户是否是刷新进入页面，如音乐播放器恢复播放进度条的功能</span><span class="token punctuation">(</span>因为它只关闭页面就丢失数据，如果是刷新的话，数据还会存在，判断的就是它的数据是否存在<span class="token punctuation">)</span>。


如何实现可过期的localstorage数据？ 
目前有两种方法，一种是惰性删除，另一种是定时删除。 惰性删除是指某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。实现方法是，存储的数据类型是个对象，该对象有两个key，一个是要存储的value值，另一个是当前时间。获取数据的时候，拿到存储的时间和当前时间做对比，如果超过过期时间就清除Cookie。 定时删除是指，每隔一段时间执行一次删除操作
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_15-js-执行机制"><a href="#_15-js-执行机制" class="header-anchor">#</a> 15.js 执行机制</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 1. 首先判断JS任务是同步的还是异步的，同步任务会在主线程的执行栈中依次执行</span>
        <span class="token comment">// 2. 异步任务会提交给异步进程处理，（比如setTimeout,click事件等，）当满足触发条件的时候，</span>
        <span class="token comment">//    异步进程会把异步任务（回调函数）放到任务队列中</span>
        <span class="token comment">// 3. 当主线程执行完所有的同步任务后，会去任务队列中查找，看是否有可以执行的异步任务，如果有，</span>
        <span class="token comment">//    放到主线程中执行，执行完之后再去任务队列中查看，依次循环。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_16-作用域"><a href="#_16-作用域" class="header-anchor">#</a> 16.作用域</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>js作用域分为全局作用域<span class="token number">2.</span>局部作用域（函数作用域和块作用域）
<span class="token comment">// 函数作用域，在函数内部声明的变量，只能在函数内部被访问</span>
<span class="token comment">//函数内部未声明直接赋值的变量，是全局变量，会挂载到window上</span>
<span class="token comment">// 函数的参数，相当于函数内部的局部变量 </span>
<span class="token comment">// 块作用域：在 JavaScript 中使用 `{}` 包裹的代码称为代码块，</span>
<span class="token comment">//  使用let/const声明的变量，在{}中就会产生块级作用域。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_17-var-let-const-区别"><a href="#_17-var-let-const-区别" class="header-anchor">#</a> 17.var let const 区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> <span class="token keyword">let</span> <span class="token keyword">const</span> 可以形成块作用域，<span class="token keyword">var</span>不可以
块级作用域解决了<span class="token constant">ES5</span>中的两个问题：
内层变量可能覆盖外层变量
用来计数的循环变量泄露为全局变量
<span class="token number">2.</span> <span class="token keyword">let</span>  <span class="token keyword">const</span> 是不存在变量提升的，<span class="token keyword">var</span>可以
<span class="token number">3.</span> <span class="token keyword">let</span> <span class="token keyword">const</span> 不能重复声明 ，<span class="token keyword">var</span>可以
<span class="token number">4.</span> <span class="token keyword">let</span> <span class="token keyword">const</span> 不能再声明之前使用（暂时性死区），<span class="token keyword">var</span>可以<span class="token punctuation">,</span><span class="token keyword">let</span> <span class="token keyword">const</span> 的暂时性死区，在声明前的作用域无法访问到<span class="token keyword">let</span> <span class="token keyword">const</span>声明的相同变量
<span class="token number">5.</span> <span class="token keyword">const</span> 声明变量的同时必须赋初始值，且不能重新赋值
<span class="token number">6.</span> 浏览器中，<span class="token keyword">var</span>声明的全局变量会挂载到window对象下，<span class="token keyword">let</span> <span class="token operator">/</span> <span class="token keyword">const</span> 不会
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_18-作用域链"><a href="#_18-作用域链" class="header-anchor">#</a> 18.作用域链</h2> <p><strong>定义</strong></p> <p>变量查找机制，先从当前作用域查找，如果没有就往上一级查找，一直查找到全局作用域（就近原则）</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">// 作用域链本质上是底层的变量查找机制，</span>
    <span class="token comment">//   在函数被执行时，会优先查找当前函数作用域中查找变量，</span>
    <span class="token comment">//   如果当前作用域查找不到则会依次逐级查找上一级作用域直到全局作用域</span>
    <span class="token comment">//   let a = 1</span>
    <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// let a = 2</span>
      <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//   a = 3</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_19-垃圾回收机制"><a href="#_19-垃圾回收机制" class="header-anchor">#</a> 19.垃圾回收机制</h2> <p><strong>垃圾回收机制</strong></p> <p>垃圾回收机制（garbage collection）简称GC， JS中内存的分配和回收是自动完成的，内存在不使用的时候会被JS引擎/垃圾回收程序自动回收。<code>一般来说回收机制，当在函数声明一个变量 函数内部声明的这个num变量，当函数执行完后，不再使用了，会`被垃圾回收程序回收掉</code> <code>全局变量是当 页面关闭 时被销毁</code></p> <p><strong>内存泄漏</strong></p> <p>内存泄漏: 不再使用的内存，没有及时的释放。</p> <ol><li><p>全局变量在页面关闭的时候会被回收</p></li> <li><p>函数里面的变量当函数调用完就回收</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>闭包  <span class="token number">2.</span>垃圾回收机制的引用计数法 <span class="token number">3.</span>意外的全局变量 <span class="token number">4</span><span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span>打印一个局部变量，或者是引用数据类型也会导致内存泄漏，所以我们项目一般上线前会把console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span>代码注释掉
<span class="token number">5.</span>、<span class="token constant">DOM</span> 元素的引用、 <span class="token number">6.</span>定时器
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol> <p><strong>垃圾回收机制的两种方法</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 引用计数法 ：跟踪每个值的引用次数，每引用一次次数累加，少引用一次，次数减少一次，当引用次数为<span class="token number">0</span>的时候，释放内存
缺陷： 堆内存空间中的对象 互相引用，计数永远不能为<span class="token number">0</span>，无法被回收，内存泄漏
<span class="token number">2.</span>标记清除法：从全局作用查找，查找得到的话，就标记为活动对象，查找不到的话标记为非活动对象，查找完之后，非活动对象回收
缺陷：内存碎片化，解决方法：标记清除整理算法
<span class="token number">3.</span>谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>栈空间的垃圾回收机制</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>当执行一段js代码，首先创建全局执行上下文，压入栈底，当执行函数的时候，会创建函数执行上下文，压入栈中，还有一个记录
当前执行状态的指针（称为 <span class="token constant">ESP</span>），当执行函数的时候<span class="token constant">ESP</span>指向这个函数 ，当执行完之后，<span class="token constant">ESP</span>指向下一个函数，当前函数的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。
函数尾调用的原理就是这样来的，尾调用节约内存，当前函数调用完，再调用另一个函数，就销毁上一个函数执行上下文，尾递归，也是这个原理，不会造成栈溺出，他表示的是一个函数在执行最后一步时自己调用自己，从始至终自会有一个函数执行上下文，所以比较节约内存
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>堆空间的垃圾回收机制</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">根据代际假说</span><span class="token punctuation">(</span><span class="token number">1.</span>大部分对象在刚分配内存，很快就变得不能访问了 <span class="token number">2.</span>不死的对象，会活得很久<span class="token punctuation">)</span>，v8中把堆分为新生代和老生代，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。新生代使用副垃圾回收器，老生代使用主垃圾回收器
<span class="token number">1.</span>新生区的垃圾回收：
新生代采用Scavenge算法，把新生代空间分为对象区域和空闲区域，新加入的对象会放到对象区域，当对象区域要满的时候，执行垃圾回收，标记活动对象，和非活动对象，所有的活动对象整理好后复制到空闲区，回收非活动对象，清理完后，空闲区和对象区进行角色互换
缺陷：新生区空间较少，很容易对象区域的内存就满了，执行垃圾回收的次数会很频繁
js引擎解决方案：对象晋升策略，凡是经过<span class="token number">2</span>次垃圾回收机制存活下来的，就会晋升到老生区
<span class="token number">2.</span>老生区的垃圾回收
老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。，老生区是主垃圾回收机制负责，采用的是标记清除法，
标记阶段：从根元素递归遍历这组根元素，查找得到标记为活动对象，查找不到标记为非活动对象，清除阶段：清除所有标记为非活动对象，
缺陷：内存碎片化 解决方案：标记整理算法 原理：这个标记过程仍然与标记 <span class="token operator">-</span> 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
全停顿： js是运行在主线程之上的，一旦执行垃圾回收算法，都需要把正在执行的js脚本暂停下来，等到垃圾回收完了再恢复，
解决方法：增量标记算法
为了降低老生代的垃圾回收而造成的卡顿，<span class="token constant">V8</span> 将标记过程分为一个个的子标记过程，同时
让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>判断对象是否存活</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>现代虚拟机基本都是采用 可达性分析算法 来判断对象是否存活，可达性算法的原理是以一系列叫做  <span class="token constant">GC</span> Root  的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。这样通过 <span class="token constant">GC</span> Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕<span class="token punctuation">,</span>如果相关对象不在任意一个以 <span class="token constant">GC</span> Root 为起点的引用链中，则这些对象会被判断为垃圾对象<span class="token punctuation">,</span>会被 <span class="token constant">GC</span> 回收。
哪些对象可以作为 <span class="token constant">GC</span> Root 呢？
<span class="token number">1.</span>虚拟机栈（栈帧中的本地变量表）中引用的对象
<span class="token number">2.</span>本地方法栈中 <span class="token constant">JNI</span>（即一般说的 Native 方法）引用的对象
<span class="token number">3.</span>方法区中类静态属性引用的对象
<span class="token number">4.</span>方法区中常量引用的对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_20-闭包"><a href="#_20-闭包" class="header-anchor">#</a> 20.闭包</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> 闭包：内层函数引用外层函数中的变量的集合，内层函数用到外层函数的变量，此时这个变量所在的这个函数就叫做闭包函数
  闭包<span class="token operator">=</span>内层函数<span class="token operator">+</span>外层函数的变量
闭包形成的原理：作用域链，当前作用域可以访问上级作用域中的变量
<span class="token literal-property property">内存泄漏</span><span class="token operator">:</span>关系到上面的栈空间的执行过程
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>闭包的问题：内存泄漏 由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出。</code></p> <p><strong>闭包的作用：</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 延伸变量的范围
<span class="token number">2.</span> 实现变量的私有化
<span class="token number">3.</span> 节流 <span class="token function">，防抖</span><span class="token punctuation">(</span>实际开发作用<span class="token punctuation">)</span>
<span class="token number">4.</span>柯里化函数的实现
<span class="token number">5.</span>能够模仿块级作用域
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_21-函数相关面试"><a href="#_21-函数相关面试" class="header-anchor">#</a> 21.函数相关面试</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 函数用<span class="token keyword">function</span>声明的函数才存在函数提升在当前作用域的顶部，用函数表达式声明的函数不会提升，因为其本质是声明变量的过程，只不过值是函数而已

<span class="token number">2.</span> <span class="token keyword">function</span>声明的函数，会被提升到当前作用域的最前面  在<span class="token keyword">var</span>的前面

<span class="token number">3.</span> 表达式的函数，如果是<span class="token keyword">var</span>声明的，只提升声明，不提升赋值（必须先声明和赋值，再调用）

<span class="token number">4.</span> <span class="token keyword">let</span> <span class="token keyword">const</span> 声明的函数必须先声明再调用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>arguments</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>每个函数内部都有arguments参数，箭头函数没有，arguments是一个伪数组，不能用数组的方法
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>rest参数</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>rest参数语法 <span class="token operator">...</span>rest ，接收剩余参数，是一个真数组，可以用数组的方法，一般我们都用rest参数代替了arguments参数
rest参数只能写在形参的最后面，否则会报错
作用：
<span class="token number">1.</span> 求最大最小值
<span class="token number">2.</span> 合并、复制数组
<span class="token number">3.</span> 用途<span class="token number">3</span> ：展开字符串
<span class="token number">4.</span> 伪数组转换为真数组
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_22-箭头函数考点"><a href="#_22-箭头函数考点" class="header-anchor">#</a> 22.箭头函数考点</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>   <span class="token number">5.</span>当箭头函数需要返回一个对象时，如果要简写，需要把对象用小括号包裹起来
    <span class="token keyword">const</span> <span class="token function-variable function">fn5</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> xxx <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token number">6.</span>箭头函数里面没有arguments，没有绑定<span class="token keyword">this</span>，<span class="token keyword">this</span>的指向是当前作用域<span class="token keyword">this</span>的指向，或上一级作用域<span class="token keyword">this</span>的指向
    <span class="token number">7.</span>箭头函数中的<span class="token keyword">this</span>指向
     <span class="token comment">// 普通函数的this：谁调用它，指向谁（跟函数定义的位置无关）</span>
    <span class="token comment">// 箭头函数的this：没有自己的this，取决于函数定义的位置（与谁调用它无关），</span>
    <span class="token comment">// 即包裹该箭头函数的第一个普通函数的this，没有包裹它的普通函数，则指向window</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>箭头函数注意点</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>没有<span class="token keyword">this</span>、<span class="token keyword">this</span>是从外部获取、不能使用<span class="token keyword">new</span>、没有arguments、没有原型和<span class="token keyword">super</span>  箭头函数相当于匿名函数，简化了函数定义
<span class="token number">1.</span> 箭头函数没有prototype属性，也没有原型
 <span class="token number">2.</span> 不能使用<span class="token keyword">new</span> 调用箭头函数，也就是说箭头函数不能作为构造函数
 <span class="token number">3.</span> 箭头函数没有arguments，利用rest接收剩余参数  <span class="token comment">//在箭头函数里访问arguments访问的是外部环境的arguments</span>
 <span class="token number">4.</span> 箭头函数本身没有<span class="token keyword">this</span> 
    <span class="token comment">//  箭头函数的this指向在定义的时候就确定了，指向的是上层作用域中的this</span>
    <span class="token comment">// ===&gt;  箭头函数内部的this指向是固定的。普通函数的this指向是可变的</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_23-浅拷贝"><a href="#_23-浅拷贝" class="header-anchor">#</a> 23.浅拷贝</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> 面试
     <span class="token constant">Q1</span>：什么是浅拷贝？
     在堆内存中新开辟空间，创建一个新的对象
     拷贝第一层基本数据类型的值和引用类型的地址
     <span class="token constant">Q2</span>：实现浅拷贝的方式有哪些？
       <span class="token number">1.</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token number">2.</span> 扩展运算符
        <span class="token number">3.</span> <span class="token function">数组的concat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">//详情见js进阶第四天</span>
        <span class="token number">4.</span><span class="token function">数组的slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token number">5</span><span class="token punctuation">.</span>Array的静态方法  Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//这个方法可以将arguments对象转换为数组</span>
其实浅拷贝也可以这样实现
<span class="token keyword">const</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'hah'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token literal-property property">yi</span><span class="token operator">:</span><span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
现在我们要把obj浅拷贝给一个空对象， <span class="token keyword">const</span> obj1<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    obj1<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span>          <span class="token comment">//这样就能实现一个简单的浅拷贝，深拷贝的原理也是根据这个来的</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="_24-深拷贝"><a href="#_24-深拷贝" class="header-anchor">#</a> 24.深拷贝</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>  面试题：
         <span class="token constant">Q1</span> <span class="token operator">:</span> 什么是深拷贝 ？

在堆内存中新开辟一个空间存放新的对象  递归的拷贝原对象的所有属性和方法，拷贝前后两个对象，相互不影响       
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Q2 : 实现深拷贝的方式？</p> <div class="language- extra-class"><pre><code>        1. JSON.parse(JSON.stringify(obj))
        缺陷：1.当属性值是undefined 和函数时，则会丢失，当然不止这两种情况会丢失，正则等等
        2. .手写递归实现
        3. 使用一些JS库，比如lodash等
        4.jQuery.extend()
</code></pre></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>  <span class="token comment">// 深拷贝 ： 在堆内存中新开辟一个空间存放新的对象</span>
    <span class="token comment">//                递归的拷贝原对象的所有属性和方法，拷贝前后两个对象，相互不影响</span>

    <span class="token comment">// 递归的拷贝：一层一层，每一层都新建一个内存空间</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'JS'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">book</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&quot;You Don't Know JS&quot;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token string">&quot;169&quot;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
手写递归实现深拷贝<span class="token punctuation">,</span>实现简单的深拷贝，很多情况都没考虑进去，只考虑了对象的属性值是对象和数组的情况
<span class="token keyword">const</span> obj2<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token parameter">ollobj<span class="token punctuation">,</span>newobj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> ollobj<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ollobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment">//为什么要先判断数组，因为，数组属于对象，如果想要不按照顺序来的话可以用                                                   Object.prototype.tostring.call() 方法 </span>
            newobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token function">clone</span><span class="token punctuation">(</span>ollobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>newobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ollobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
               newobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
             <span class="token function">clone</span><span class="token punctuation">(</span>ollobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>newobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
              newobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>ollobj<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
     
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 <span class="token function">clone</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>obj1<span class="token punctuation">)</span>
      
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="_25-js实现继承的方式"><a href="#_25-js实现继承的方式" class="header-anchor">#</a> 25. js实现继承的方式</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 原型链继承  
<span class="token number">2.</span> 借用构造函数（经典继承）
<span class="token number">3.</span> 组合继承
<span class="token number">4.</span> 原型式继承
<span class="token number">5.</span> 寄生式继承
<span class="token number">6.</span> 寄生式组合继承 <span class="token operator">==</span><span class="token operator">&gt;</span> 最完美的
<span class="token number">7.</span> <span class="token keyword">extends</span><span class="token function">继承</span> <span class="token punctuation">(</span><span class="token operator">===</span><span class="token operator">&gt;</span>语法糖，寄生式组合继承<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>原型链继承</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>原理：子构造函数的原型等于父构造函数的实例
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>寄生式继承</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>   <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'哈UN沟通与内购会'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span>
    obj2<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> obj      <span class="token comment">//原理</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_26-call-aplly-bind-面试题"><a href="#_26-call-aplly-bind-面试题" class="header-anchor">#</a> 26.call aplly bind 面试题</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">// 总结 </span>
<span class="token comment">// 面试题</span>
call <span class="token operator">/</span> apply<span class="token operator">/</span> bind 的区别
call<span class="token operator">/</span>apply<span class="token operator">/</span>bind的核心理念：借用方法。
借助已实现的方法，改变方法中数据的<span class="token keyword">this</span>指向，减少重复代码，节省内存。
<span class="token number">1.</span>都是改变<span class="token keyword">this</span>的指向 
<span class="token number">2</span><span class="token punctuation">.</span>call接收的是参数列表，apply接收的是数组 <span class="token punctuation">,</span>他们两个都会立即调用函数
<span class="token number">3</span><span class="token punctuation">.</span>call和aplly是立即执行的，bind返回一个已经改变<span class="token keyword">this</span>的函数，需要手动调用​
<span class="token number">4.</span>调用call<span class="token operator">/</span>apply<span class="token operator">/</span>bind的必须是个函数，call、apply和bind是挂在Function对象上的三个方法<span class="token punctuation">,</span>只有函数才有这些方法。
<span class="token literal-property property">应用场景</span><span class="token operator">:</span>
<span class="token number">1.</span>判断数据类型 <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">2.</span>类数组借用数组的方法
<span class="token number">3</span><span class="token punctuation">.</span>apply获取数组最大值最小值  <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">const</span> max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 16</span>
<span class="token number">4.</span>继承 <span class="token constant">ES5</span>的继承也都是通过借用父类的构造方法来实现父类方法<span class="token operator">/</span>属性的继承
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>call源码实现</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_call</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span>  <span class="token comment">//Symbol 是创建一个独一无二的属性，防止与原对象属性冲突覆盖</span>
    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>          <span class="token comment">//这里的this就是要改变this指向的那个函数</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token keyword">delete</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
fn<span class="token punctuation">.</span><span class="token function">_call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>aplly源码实现</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>​
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_aplly</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span>  <span class="token comment">//Symbol 是创建一个独一无二的属性，防止与原对象属性冲突覆盖</span>
     obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>          <span class="token comment">//这里的this就是要改变this指向的那个函数</span>
     <span class="token keyword">let</span> result <span class="token operator">=</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
     <span class="token keyword">delete</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
fn<span class="token punctuation">.</span><span class="token function">_aplly</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>bind源码实现</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>•
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_bind</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span>
    <span class="token comment">//Symbol 是创建一个独一无二的属性，防止与原对象属性冲突覆盖   </span>
    obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">;</span>          <span class="token comment">//这里的this就是要改变this指向的那个函数    </span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>  
    <span class="token keyword">delete</span> obj<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>    
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
fn<span class="token punctuation">.</span><span class="token function">_bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_27-防抖"><a href="#_27-防抖" class="header-anchor">#</a> 27.防抖</h2> <p>什么是防抖： 这题可以补充一些防抖或节流在页面中的应用场景，会加分</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>防抖：debounce
    <span class="token comment">// 当持续触发事件时，一定时间内没有再触发事件，回调函数才会执行一次。</span>
    <span class="token comment">// 如果设定的延迟时间到来之前，又触发了事件，就重新计时。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>防抖的场景</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>防抖：防止抖动，你先抖动着，啥时候停了，再执行下一步。
    <span class="token comment">// 游戏 回城键 b回城。按下了回城键，等待5s回城。再5s之内，继续又按一下回城，又会重新计时。</span>
    <span class="token comment">// 防抖的应用场景</span>
    <span class="token comment">// 1. 搜索框输入查询的时候</span>
    <span class="token comment">// 2. 鼠标连续点击按钮提交等</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>防抖函数</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sendMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>ms<span class="token operator">=</span><span class="token number">0</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
        timer<span class="token operator">=</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> 
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>      <span class="token comment">//这里用call的原因是因为事件里面的回调函数本来是指向事件源的，但这里的fn的this是指向window的，但为什么call的第一个参数是this，是因为箭头函数没有自己的this，会往上一层作用域去找，return function中的this是指向事件源的，所以用this</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>ms<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
   input<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'keyup'</span><span class="token punctuation">,</span> <span class="token function">debounce</span><span class="token punctuation">(</span>sendMsg<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_28-节流"><a href="#_28-节流" class="header-anchor">#</a> 28.节流</h2> <p><strong>什么是节流</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>节流：throttle
    <span class="token comment">// 持续的触发事件，在一段时间内，只允许函数执行一次</span>
    <span class="token comment">// ==&gt; 节流：减少一段时间内，事件的触发频率</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>应用场景</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>应用场景：
    <span class="token comment">// 1. 浏览器窗口缩放 ，resize事件</span>
    <span class="token comment">// 2. scroll滚动事件 / mousemove 事件等。</span>
   <span class="token comment">//滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>节流定时器版</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;box&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">const</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.box'</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">const</span> <span class="token function-variable function">move</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 只要鼠标一移动，i就会变化</span>
      box<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> i<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// box.addEventListener('mousemove', move)</span>



    <span class="token comment">// 节流：throttle</span>
    <span class="token comment">// 持续的触发事件，在一段时间内，只允许函数执行一次</span>
    <span class="token comment">// ==&gt; 节流：减少一段时间内，事件的触发频率</span>

    <span class="token comment">// 应用场景：</span>
    <span class="token comment">// 1. 浏览器窗口缩放 ，resize事件</span>
    <span class="token comment">// 2. scroll滚动事件 / mousemove 事件等。</span>

    <span class="token comment">// 需求： 每隔100ms只执行一次。setTimeout</span>
    <span class="token comment">// 整个程序 ，应该只有一个定时器在走</span>
    <span class="token keyword">const</span> <span class="token function-variable function">throttle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> ms <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> timerId
      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//如果没有定时器，就开启定时器</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timerId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">//开启第一个定时器后</span>
          timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
            <span class="token comment">//这里，让下一次定时器又可以开启</span>
            timerId <span class="token operator">=</span> <span class="token keyword">null</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span>move<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p><strong>节流时间戳版</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;box&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">const</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.box'</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">const</span> <span class="token function-variable function">move</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 只要鼠标一移动，i就会变化</span>
      box<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> i<span class="token operator">++</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 需求 ：每隔100ms 只执行一次 。</span>
    <span class="token comment">// 时间戳的写法</span>
    <span class="token keyword">const</span> <span class="token function-variable function">throttle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> ms <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token number">0</span>
      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> pre <span class="token operator">&gt;</span> ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">move</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
          pre <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> <span class="token function">throttle</span><span class="token punctuation">(</span>move<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="_29-lodash防抖节流"><a href="#_29-lodash防抖节流" class="header-anchor">#</a> 29.lodash防抖节流</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;box&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;./lodash.min.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">const</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.box'</span><span class="token punctuation">)</span>

    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">const</span> <span class="token function-variable function">move</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      box<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> i<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 节流 _.throttle(fn, ms)</span>
    <span class="token comment">// 防抖 _.debounce(fn, ms)</span>

    <span class="token comment">// box.addEventListener('mousemove', _.throttle(move, 10))</span>
    box<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> _<span class="token punctuation">.</span><span class="token function">debounce</span><span class="token punctuation">(</span>move<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// ----------------------------------------------------------------------------------</span>
    <span class="token comment">// 防抖和节流的面试点</span>

    <span class="token comment">// 1. 能说出什么是防抖，什么是节流</span>
    <span class="token comment">// 防抖： 你先抖动着，什么时候停了，我再执行。</span>
    <span class="token comment">// ===&gt; 防抖是将多次密集触发，合并为一次。</span>

    <span class="token comment">// 节流：减少一定时间内，事件触发的频率。 （减少水流）</span>


    <span class="token comment">// 2. 能说出它们的应用场景</span>

    <span class="token comment">// 应用场景：</span>
    <span class="token comment">// 防抖：1. 搜索框输入查询</span>
    <span class="token comment">//      2. 多次点击按钮提交</span>

    <span class="token comment">// 节流：</span>
    <span class="token comment">//     1. 窗口的resize事件</span>
    <span class="token comment">//     2. scroll事件，mousemove事件等。</span>

    <span class="token comment">// 3. ==&gt; 高级一点，手写防抖节流</span>

    <span class="token comment">// 防抖</span>
    <span class="token keyword">const</span> <span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> ms <span class="token operator">=</span> <span class="token number">0</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> timerId
      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timerId<span class="token punctuation">)</span>
        timerId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

        <span class="token comment">// 节流</span>
        <span class="token comment">// 事件戳版本 / 定时器版本</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><h2 id="_30-extends继承"><a href="#_30-extends继承" class="header-anchor">#</a> 30.extends继承</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">// 寄生式组合继承 </span>
    <span class="token comment">// ===&gt; extends ES6 类的继承  完美的 perfect~~~</span>
    <span class="token comment">// 继承： 让子类拥有父类的属性和方法</span>
    <span class="token comment">//定义一个父类</span>
    <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
      <span class="token punctuation">}</span>
      <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'奔跑'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 写一个子Dog 继承Animal 这个父类</span>
    <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">'西瓜'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dog<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 子类 创建的实例，可以调用父类的方法 （继承父类的属性和方法）</span>
<span class="token comment">// 子类里面没有写属性和方法，但是 通过extends，直接继承了父类的name和age</span>
<span class="token comment">// 子类 创建的实例，可以调用父类的方法 （继承父类的属性和方法）</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="_31-super-继承"><a href="#_31-super-继承" class="header-anchor">#</a> 31.super 继承</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token comment">// 定义一个父类</span>
    <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 定义一个son继承Father</span>
    <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 1. 子类实现继承的时候必须在constructor方法里面，调用super(), 否则会报错。</span>
    <span class="token comment">//  ===&gt; 如果子类里面写了constructor() ，就必须要写super()</span>
    <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 2. 如果子类没有写constructor(), 这个方法会默认添加，并且里面还会默认调用super()</span>

    <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 等同于</span>
    <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

        <span class="token comment">// 正常情况下，我们都会在子类里写constructor，并且写super()</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p><strong>super注意点</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 定义父类</span>
    <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这里的constructor叫做构造函数</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 求和 </span>
      <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 定义一个子类，继承父类</span>
    <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1. super() 必须在子类的this前面调用</span>
      <span class="token comment">// 2. super() 代表了父类的构造函数</span>
      <span class="token comment">// 3. super() 里面的this 指向的是谁呢？</span>
      <span class="token comment">//  ===&gt; 指向的是子类的实例，Son的实例 p这个对象</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">// ==&gt; super(x, y)  父类的constructor(x, y)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color

      <span class="token punctuation">}</span>

      <span class="token comment">// 4. 怎么理解super()要在this前面调用？</span>
      <span class="token comment">// 我们现在是不是在实现继承，让子类拥有父类的属性和方法</span>
      <span class="token comment">// 我们需要先继承父类的属性和方法，然后再扩展自己的属性和方法。</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token number">1.</span> 子类不能往父类构造函数传参， 通过<span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 就可以往父类构造函数传参
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h2 id="_32-事件循环"><a href="#_32-事件循环" class="header-anchor">#</a> 32.事件循环</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>老师的：  答的时候随便答一下<span class="token keyword">this</span><span class="token punctuation">.</span>$nextTick
<span class="token comment">//     事件循环（eventloop）:</span>
<span class="token comment">// 1、主线程上面的同步代码，</span>
<span class="token comment">// 2、取出微任务列表里面所有的微任务，全部执行</span>
<span class="token comment">// 3、取出宏任务队列里面的一个宏任务，执行</span>
<span class="token comment">// 4、继续执行第2步</span>
<span class="token comment">// 5、继续执行第3步</span>
<span class="token comment">// 6、继续执行第2步</span>
<span class="token comment">// 7、继续执行第3步</span>
我的：
事件循环，最开始，执行script这个宏任务，执行过程中，同步任务立即执行，宏任务放入宏任务队列中，微任务放入微任务队列中，等整个script脚本这个宏任务执行完之后，再去微任务队列中看有没有需要执行的微任务如果有的话就依次执行，执行完了之后，执行完，是否需要渲染页面<span class="token punctuation">,</span>浏览器更新渲染完成，去看宏任务队列中是否有宏任务，如果有拿一个出来执行，执行完了之后再去看微任务队列中有需要执行的微任务，如果有，全部执行完，再去宏任务里看，依次循环
浏览器和Node 环境下，微任务 任务队列的执行时机不同 <span class="token operator">-</span> Node端，微任务 在事件循环的各个阶段之间执行 <span class="token operator">-</span> 浏览器端，微任务 在事件循环的 宏任务 执行完之后执行
node的几大阶段
<span class="token number">1</span><span class="token punctuation">.</span>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调
<span class="token number">2.</span><span class="token constant">I</span><span class="token operator">/</span><span class="token constant">O</span> callbacks 阶段：处理一些上一轮循环中的少数未执行的 <span class="token constant">I</span><span class="token operator">/</span><span class="token constant">O</span> 回调
<span class="token number">3</span><span class="token punctuation">.</span>idle<span class="token punctuation">,</span> prepare 阶段：仅node内部使用
<span class="token number">4</span><span class="token punctuation">.</span>poll 阶段：获取新的<span class="token constant">I</span><span class="token operator">/</span><span class="token constant">O</span>事件<span class="token punctuation">,</span> 适当的条件下node将阻塞在这里
<span class="token number">5</span><span class="token punctuation">.</span>check 阶段：执行 <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 的回调
<span class="token number">6</span><span class="token punctuation">.</span>close callbacks 阶段：执行 socket 的 close 事件回调
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div> <p><img src="/myblog/assets/img/image-20230219132516276.4000e1ed.png" alt="Algolia搜索"></p> <h2 id="_33-宏任务-微任务"><a href="#_33-宏任务-微任务" class="header-anchor">#</a> 33.宏任务 微任务</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// Event Loop 事件循环</span>
 宏任务：
<span class="token comment">// 1. script代码块</span>
<span class="token comment">// 2. setTimeout / setInterval </span>
<span class="token comment">// 3. setImmediate</span>
 <span class="token comment">//4.UI rendering</span>
 <span class="token comment">//5.I/O</span>
 <span class="token comment">//6.MessageChannel</span>

 微任务：
<span class="token comment">// 1. promise.then() 和 promise.catch()</span>
<span class="token comment">// 2. async await (generator和yeild的语法糖)  ==&gt; await 这一行后面的那些会放到微任务队列中</span>
<span class="token keyword">const</span> <span class="token function-variable function">asyncReadFile</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// await 这一行的代码，同步执行的</span>
  <span class="token keyword">const</span> f1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'/etc/fstab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// await 后面的代码会放到微任务队列中</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 3.MutationObserver  ==&gt; 监听DOM元素的变化，执行回调函数</span>
<span class="token comment">// 4.process.nextTick  ==&gt; node中的</span>
<span class="token comment">//5.Object.observe</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p><strong>事件循环理解</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 1. 微任务是包含在宏任务里面的吗？</span>
<span class="token comment">// 一个宏任务可以包含微任务</span>
<span class="token comment">// 2. 一个宏任务里面可以有多个微任务吗？ 可以 </span>

<span class="token comment">// 3. 什么时候是一个宏任务结束呢 ， 当当前宏任务中的所有微任务队列清空完，本轮tick执行完</span>
<span class="token comment">//    之后，再执行下一个宏任务 </span>


<span class="token comment">// 微任务在本次事件循环的最后吗 是</span>

<span class="token comment">// 1. 首先script代码块可以看做第一个宏任务，开始第一个Tick事件循环</span>
<span class="token comment">// 2. 会先执行script代码块中的同步代码，</span>
<span class="token comment">// 3. 如果遇到宏任务，就放到宏任务队列中等待执行,  如果遇到微任务，放到微任务队列中</span>
<span class="token comment">// 3. 当主线程执行完同步代码的时候，首先，去微任务队列中清空当前事件循环的所有微任务 （本轮事件循环Tick结束）</span>
<span class="token comment">// 4. 再去执行下一个宏任务  ==&gt; 这个时候是下一次事件循环了</span>


<span class="token comment">// 0 2 4 3 666 888 （本轮宏任务执行完）==&gt; log 1 是下一个宏任务</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 宏任务队列 1  // 遇到宏任务了，把这里的回调函数 放到宏任务队列中等待执行</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// new Promise内部这里的代码，同步执行 </span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 可以跳过</span>
  <span class="token comment">// resolve()</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里的.then() 这块代码，放到微任务队列中执行</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 又放到微任务队列中</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 微任务队列</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">888</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 宏任务和微任务的关系</span>
<span class="token comment">// 拔萝卜 萝卜上面有泥巴~~~</span>
<span class="token comment">// 执行一个宏任务，就相当于拔一个萝卜， 这些泥就相当于是这次循环的所有微任务，</span>
<span class="token comment">// 我们需要把泥洗干净（清空当前循环的所有微任务队列）</span>
<span class="token comment">// 之后再去执行下一个宏任务，拔下个萝卜</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br></div></div><p><strong>面试题</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里的代码是同步执行的 </span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 start'</span><span class="token punctuation">)</span>
  <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// 注意： await 这一行是同步执行的</span>
  <span class="token comment">// 下面的代码相当于.then()中的代码，会放到微任务队列中执行 </span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span> <span class="token comment">// 微-1</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>  <span class="token comment">// 宏-1 </span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span> <span class="token comment">// 微-2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span> <span class="token comment">// 微-3</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
<span class="token comment">// 1. script start</span>
<span class="token comment">// 2. async1 start</span>
<span class="token comment">// 3. async2</span>
<span class="token comment">// 4. Promise</span>
<span class="token comment">// 5. script end</span>
<span class="token comment">// 6. async1 end</span>
<span class="token comment">// 7. promise1</span>
<span class="token comment">// 8. promise2  ===&gt; 本轮宏任务结束</span>
<span class="token comment">// 9. setTimeout</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h2 id="_34-this是如何工作的"><a href="#_34-this是如何工作的" class="header-anchor">#</a> 34.this是如何工作的</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">this</span> 被自动定义在所有函数的作用域中除了箭头函数，它提供了一种更好的方式来“隐式”的传递对象引用，这样使得我们的 <span class="token constant">API</span> 设计或者函数变得更加简洁，而且还更容易复用。
<span class="token number">1.</span>在非严格模式下
普通函数调用：<span class="token keyword">this</span>指向调用者
构造函数调用：<span class="token keyword">this</span>指向实例
对象的方法调用：<span class="token keyword">this</span>指向对象
事件绑定的回调函数：<span class="token keyword">this</span>指向事件源
定时器：<span class="token keyword">this</span>指向window
立即执行函数：<span class="token keyword">this</span>指向window
<span class="token number">2.</span>在严格模式下
开启严格模式 在script标签或函数里写一个字符串<span class="token string">'use strict'</span>
首先严格模式，不允许未声明就赋值，以前 未声明就赋值，默认是全局变量
严禁删除已经声明的变量 例 <span class="token keyword">delete</span> 变量名
<span class="token keyword">this</span> 指向改变
普通函数window调用 ，<span class="token keyword">this</span>指向<span class="token keyword">undefined</span>
以前构造函数不加<span class="token keyword">new</span>也可以调用，严格模式，构造函数必须加<span class="token keyword">new</span>调用
其余都没变

但在<span class="token constant">JS</span>中并不是所有的对象都可以被删除的
<span class="token constant">JS</span>中通过 <span class="token keyword">var</span>\<span class="token keyword">function</span> 声明因含有DontDelete，而不可被删除：
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> x<span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token keyword">typeof</span> x<span class="token punctuation">;</span> <span class="token comment">// 1</span>


<span class="token keyword">function</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">delete</span> x<span class="token punctuation">;</span> <span class="token comment">// false</span>
<span class="token keyword">typeof</span> x<span class="token punctuation">;</span> <span class="token comment">// &quot;function&quot;</span>


但是对象的属性、数组成员却是可以删除的：

<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> o<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token keyword">typeof</span> o<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// undefined</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h2 id="_35-js模块化"><a href="#_35-js模块化" class="header-anchor">#</a> 35.js模块化</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>概念：
    <span class="token number">1.</span> 把一个大的程序拆分成<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">互相依赖</span><span class="token template-punctuation string">`</span></span>的若干<span class="token operator">**</span>小文件<span class="token operator">**</span>
    <span class="token number">2.</span> 这些小文件还可以通过<span class="token operator">**</span>特定的语法<span class="token operator">**</span>组合到一起
    <span class="token number">3.</span> 这个过程称之为<span class="token operator">**</span>模块化<span class="token operator">**</span> 
      <span class="token operator">**</span>优点：<span class="token operator">**</span>   
        <span class="token number">1.</span> 更好维护   
        <span class="token number">2.</span> 更好的复用性
        主要的两个模块：<span class="token number">1</span><span class="token punctuation">.</span>common<span class="token punctuation">.</span>js模块   es6 Meldule
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_36-说说匿名函数"><a href="#_36-说说匿名函数" class="header-anchor">#</a> 36.说说匿名函数</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>匿名函数： 没有名字的函数，用函数表达式声明的函数就是匿名函数
例： <span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token function">调用fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
匿名函数的作用：
<span class="token number">1</span>、通过匿名函数可以实现闭包（必须掌握的知识点）
<span class="token number">2</span>、模拟块级作用域，减少全局变量。执行完匿名函数，存储在内存中相对应的变量会被销毁，使用块级作用域，会大大降低命名冲突的问题，不必担心搞乱全局作用域了。
真正的匿名函数
  <span class="token comment">// 推荐使用</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'zxx'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//加小括号调用  这就是立即执行函数，所以说立即执行函数也是匿名函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_37-说说立即执行函数"><a href="#_37-说说立即执行函数" class="header-anchor">#</a> 37.说说立即执行函数</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>声明一个函数，并马上调用这个匿名函数就叫做立即执行函数。在定义好一个函数后，直接执行。
语法：
<span class="token number">1.</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>作用：
<span class="token number">1</span>、避免了污染全局变量。
<span class="token number">2</span>、立即执行函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。
<span class="token number">3</span>、封装变量。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_38-说说函数柯里化"><a href="#_38-说说函数柯里化" class="header-anchor">#</a> 38.说说函数柯里化</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>什么是函数柯里化：
<span class="token number">1.</span>柯里化就是将函数拆分成两个函数，每个函数都只接受一个参数，返回函数
<span class="token number">2.</span>柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary
作用：函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 或者采用箭头函数写法</span>
<span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token operator">=&gt;</span> <span class="token parameter">y</span> <span class="token operator">=&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token keyword">const</span> f <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_39-如何判断一个变量是不是数组"><a href="#_39-如何判断一个变量是不是数组" class="header-anchor">#</a> 39.如何判断一个变量是不是数组</h2> <p><code>1.Array.isArray()</code></p> <p><code>2.构造函数的coustructor</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>        <span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a2<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'Array'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//a2相当于Array的实例，a2.constructor指向Array，再调用Function上的toString()方法，把构造函数Array转化为字符串</span>
<span class="token comment">//再调用indexOf()方法， function Array(){},判断Array是不是在这个字符串是第9个</span>
<span class="token comment">//注意： Array 和Object的__proto__都指向Function的prototype</span>
<span class="token comment">// Array 和Object 都是构造函数，都是Function创建出来的实例</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>3. instanceof</code></p> <p><code>4. Object.prototype.toString.call()</code></p> <p><code>5. **isPrototypeOf()**</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>        <span class="token keyword">let</span> a3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>a3<span class="token punctuation">)</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_40-原始值类型包装"><a href="#_40-原始值类型包装" class="header-anchor">#</a> 40.原始值类型包装</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>问题：为什么简单数据类型没有对象的特征，却可以调用这些方法，我最开始以为的是，这种声明字符串的方法，就是利用String构造函数实例化str，str是实例了，自然可以调用原型上的方法，然而却不是的，当这种简单数据类型，调用方法时，js内部会做三件事，
<span class="token number">1.</span>创建一个String的实例
<span class="token number">2.</span>调用实例上的特定方法
<span class="token number">3.</span>销毁实例
<span class="token keyword">let</span> str <span class="token operator">=</span><span class="token string">'123'</span>
str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>    以上两句代码js在内部相当于做了一下代码
<span class="token number">1.</span> <span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span> 或 <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">2.</span>  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token number">3.</span>  str <span class="token operator">=</span> <span class="token keyword">null</span>
这也就意味着，简单数据类型不能像引用类型一样自由的添加属性
<span class="token number">1.</span> JavaScript也可以使用Object函数显式地将基本类型转换为包装类型：
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'abc'</span>
<span class="token function">Object</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// String {&quot;abc&quot;}</span>
<span class="token number">2.</span> 也可以使用valueOf方法将包装类型倒转成基本类型：
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'abc'</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 'abc'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_41-和-的区别以及扩展es6方法"><a href="#_41-和-的区别以及扩展es6方法" class="header-anchor">#</a> 41.==和===的区别以及扩展es6方法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">==</span><span class="token operator">:</span>会隐式转换数据类型，只比较值，不比较数据类型，返回布尔值
<span class="token operator">===</span>：不会转换数据类型，值和数据类型都相等才返回<span class="token boolean">true</span>
es6新增了一个Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 严格判断两个值是否相等，能判断<span class="token number">NaN</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span><span class="token number">NaN</span><span class="token punctuation">)</span>  <span class="token comment">//true</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment">//false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_42-同源策略"><a href="#_42-同源策略" class="header-anchor">#</a> 42.同源策略</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>同源：两个url的协议 <span class="token function">主机</span><span class="token punctuation">(</span>域名<span class="token punctuation">)</span> 端口 一致 则同源，否则跨域
同源策略：浏览器提供的一种安全策略，只在浏览器上存在，不允许两个不同的url进行交互
解决跨域：
<span class="token number">1</span>，<span class="token constant">CORS</span> ：设置响应头：后端的事情
<span class="token number">2.</span> 起一个服务器
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_43-null和undefined的区别"><a href="#_43-null和undefined的区别" class="header-anchor">#</a> 43.null和undefined的区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">null</span><span class="token operator">:</span>表示一个空对象指针，在获取 <span class="token constant">DOM</span> 元素时<span class="token punctuation">,</span>如果没有获取到<span class="token punctuation">,</span>返回的是 <span class="token keyword">null</span><span class="token punctuation">,</span>原型链的最顶端也是 <span class="token keyword">null</span>，<span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token comment">//Object</span>
 <span class="token keyword">null</span>转化为number是<span class="token number">0</span>
<span class="token keyword">undefined</span>：
<span class="token number">1.</span>一般定义了变量未赋值
<span class="token number">2.</span>访问对象中没有这个属性
<span class="token number">3.</span>访问函数的形参时，没有传实参
<span class="token number">4.</span>函数没有<span class="token keyword">return</span>，调用的结果也是<span class="token keyword">undefined</span><span class="token punctuation">,</span>以及<span class="token keyword">return</span> 后面没有值
<span class="token keyword">undefined</span> 转化为number 是 <span class="token number">NaN</span>

<span class="token keyword">undefined</span> 表示一个变量初始状态值，而 <span class="token keyword">null</span> 则表示一个变量被认为的设置为空对象，而不是原始状态 ，当需要释放一个对象时，直接赋值为 <span class="token keyword">null</span> 即可。即表示该对象已经被清空，目前无效状态。 <span class="token constant">GC</span> 会择机回收该值并释放内存

<span class="token keyword">null</span> 其实属于自己的类型 Null，而不属于Object类型，<span class="token keyword">typeof</span> 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，二进制的前三位为 <span class="token number">0</span> 会被 <span class="token keyword">typeof</span> 判断为对象类型，而 <span class="token keyword">null</span> 的二进制位恰好都是 <span class="token number">0</span> ，因此，<span class="token keyword">null</span> 被误判断为 Object 类型
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_44-说一下内存泄漏"><a href="#_44-说一下内存泄漏" class="header-anchor">#</a> 44.说一下内存泄漏</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>内存的生命周期：
<span class="token number">1.</span>分配所需要的内存
<span class="token number">2.</span>在内存中进行读写操作
<span class="token number">3.</span>垃圾清除，释放 <span class="token operator">/</span>回收内存
js中在定义变量，就已经分配好内存，同时也提供了垃圾回收的机制，回收那些不在需要使用的内存，
内存泄漏：程序认为一个变量已经没有在使用了，而垃圾回收机制认为它还在使用，从而导致这段内存无法释放，造成内存泄漏
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>内存泄漏的几种方式</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>闭包  <span class="token number">2.</span>垃圾回收机制的引用计数法 <span class="token number">3.</span>意外的全局变量 <span class="token number">4</span><span class="token punctuation">.</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span>打印一个局部变量，或者是引用数据类型也会导致内存泄漏，所以我们项目一般上线前会把console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span>代码注释掉
<span class="token number">5.</span>、<span class="token constant">DOM</span> 元素的引用、 <span class="token number">6.</span>定时器
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_45-说一下script标签中的defer-和async属性"><a href="#_45-说一下script标签中的defer-和async属性" class="header-anchor">#</a> 45.说一下script标签中的defer 和async属性</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>script无属性：
<span class="token number">1.1</span> 个人理解：无属性的话，如果不是放在html的尾部，放在头部的话就一定会阻塞<span class="token constant">HTML</span>的解析，遇到无属性的script标签，则会先加载脚本，再执行脚本，执行完之后，再解析<span class="token constant">HTML</span>，如果途中又遇到无属性的script标签，则又会停止对<span class="token constant">HTML</span>的解析，多个连续的无属性脚本请求加载和执行顺序与出现在文档中的顺序相同，而且一个脚本的加载请求一定是在上一个脚本执行完之后才开始的，

script标签<span class="token keyword">async</span>属性：
<span class="token number">2.1</span> 个人理解：script的<span class="token keyword">async</span>属性不一定会阻塞<span class="token constant">HTML</span>的解析，但是<span class="token keyword">async</span>属性可以在加载脚本的同时解析<span class="token constant">HTML</span>，但是如果加载脚本完成了，<span class="token constant">HTML</span>还没解析完，就会阻塞<span class="token constant">HTML</span>的解析，并且立即执行脚本，执行完之后，再对<span class="token constant">HTML</span>进行解析，如果加载脚本的过程中，<span class="token constant">HTML</span>已经解析完毕了，则就不会出现解析的情况了，当有多个<span class="token keyword">async</span>属性的script时，不一定会按照html的出现顺序相同，与脚本的加载成功顺序有关
<span class="token number">3</span><span class="token punctuation">.</span>defer脚本  不会阻塞<span class="token constant">HTML</span>的解析，即使该脚本请求加载可以和<span class="token constant">HTML</span>解析并行，但是脚本的执行会被安排在<span class="token constant">HTML</span>解析完成后之后，多个连续的defer脚本一定按照文档中的顺序执行
<span class="token number">3.1</span> 个人理解：defer脚本，一定不会阻塞<span class="token constant">HTML</span>的解析，当遇到defer的script属性的脚本，先会加载脚本，并解析<span class="token constant">HTML</span>，当defer脚本加载完了之后，并不会立马执行脚本，是等<span class="token constant">HTML</span>解析完毕后，再执行defer脚本，多个defer脚本，一定是按照出现在<span class="token constant">HTML</span>文档中的顺序执行的
相同之处：
script标签的defer和<span class="token keyword">async</span>属性都是去异步加载外部的<span class="token constant">JS</span>脚本文件，加载的过程中不会阻塞浏览器对<span class="token constant">HTML</span>的解析过程（注意：这里说的仅仅是加载的过程）
<span class="token comment">//下面2中方法也可以延迟脚本执行</span>
动态加载脚本：通过 JavaScript 动态创建 script 标签，并设置其 src 属性来实现脚本的异步加载，这种方式需要在脚本加载完成后手动执行脚本。
懒加载模式：在需要时再加载脚本，可以使用 jQuery 等库实现，或者通过自己编写的函数来实现
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><img src="%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230120105153309.png" alt="image-20230120105153309"></p> <p><strong>使用场景</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>在什么场景下用什么类型的脚本呢？

如果脚本是模块化的并且不依赖任何脚本，那么使用<span class="token keyword">async</span>脚本
如果脚本依赖另一个脚本或被另一个脚本依赖，则使用defer脚本
如果脚本很小并且被另一个<span class="token keyword">async</span>脚本所依赖，那么可以将无属性的脚本放置在<span class="token keyword">async</span>脚本之上
因为这样我们可以确保<span class="token keyword">async</span>脚本一定在无属性脚本之后执行
一般来说我们的脚本都要放置在文档的底部，因为考虑到无属性脚本和<span class="token keyword">async</span>脚本都有可能会阻塞<span class="token constant">HTML</span>的解析，当然defer脚本是可以随便放的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>为什么会导致阻塞</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>渲染阻塞的原因： 由于 JavaScript 是可操纵 <span class="token constant">DOM</span> 的<span class="token punctuation">,</span>如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 <span class="token constant">UI</span> 线程同时运行）<span class="token punctuation">,</span>那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果<span class="token punctuation">,</span>浏览器设置 <span class="token constant">GUI</span> 渲染线程与 JavaScript 引擎为互斥的关系。当浏览器在执行 JavaScript 程序的时候<span class="token punctuation">,</span><span class="token constant">GUI</span> 渲染线程会被保存在一个队列中<span class="token punctuation">,</span>直到 <span class="token constant">JS</span> 程序执行完成<span class="token punctuation">,</span>才会接着执行。如果 <span class="token constant">JS</span> 执行的时间过长<span class="token punctuation">,</span>这样就会造成页面的渲染不连贯<span class="token punctuation">,</span>导致页面渲染加载阻塞的感觉
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_46-说一下-web-worker"><a href="#_46-说一下-web-worker" class="header-anchor">#</a> 46.说一下 web worker</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>在 <span class="token constant">HTML</span> 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。
'如何创建 web worker：
<span class="token number">1.</span>检测浏览器对于 web worker 的支持性
<span class="token number">2.</span>创建 web worker 文件（js，回传函数等）
<span class="token number">3.</span>创建 web worker 对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_47-说一下什么是可变对象什么是不可变对象"><a href="#_47-说一下什么是可变对象什么是不可变对象" class="header-anchor">#</a> 47.说一下什么是可变对象什么是不可变对象</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">可变对象</span><span class="token operator">:</span>把对象a赋值给对象b，更改对象b的属性值，被引用的对象a也随之改变，这就是可变对象。
不可变对象：Object<span class="token punctuation">.</span>preventExtensions（不可扩展）、Object<span class="token punctuation">.</span>seal（密封）、Object<span class="token punctuation">.</span>freeze（冻结）。参数是对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_48-set-和-map有什么区别"><a href="#_48-set-和-map有什么区别" class="header-anchor">#</a> 48.Set 和 Map有什么区别？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span>、Map可以通过<span class="token keyword">get</span>方法获取值，而<span class="token keyword">set</span>不能因为它只有值
<span class="token number">2</span>、都能通过迭代器进行<span class="token keyword">for</span><span class="token operator">...</span><span class="token keyword">of</span> 遍历
<span class="token number">3</span><span class="token punctuation">.</span>set 是es6 提供的一种新的数据结构，它类似于数组，但是成员的值都是唯一的。
<span class="token number">4</span><span class="token punctuation">.</span>map 是es6 提供的一种新的数据结构<span class="token punctuation">,</span>它类似于对象，也是键值对的集合，但是键的范围不仅限于字符
串，各种类型的值都可以当做键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供
了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object
更合适。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div> <p><img src="/myblog/assets/img/image-20230305152342255.f7dc7860.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">-</span> <span class="token operator">**</span>size<span class="token operator">**</span>： <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">map.size</span><span class="token template-punctuation string">`</span></span> 返回Map结构的成员总数。
<span class="token operator">-</span> <span class="token operator">**</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token operator">**</span>：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）
<span class="token operator">-</span> <span class="token operator">**</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">**</span>：该方法读取key对应的键值，如果找不到key，返回<span class="token keyword">undefined</span>。
<span class="token operator">-</span> <span class="token operator">**</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">**</span>：该方法返回一个布尔值，表示某个键是否在当前Map对象中。
<span class="token operator">-</span> <span class="token operator">**</span><span class="token keyword">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">**</span>：该方法删除某个键，返回<span class="token boolean">true</span>，如果删除失败，返回<span class="token boolean">false</span>。
<span class="token operator">-</span> <span class="token operator">**</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">**</span>：map<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>清除所有成员，没有返回值。
<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
     <span class="token punctuation">[</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
     <span class="token punctuation">[</span><span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_49-如何将类数组转化为真数组"><a href="#_49-如何将类数组转化为真数组" class="header-anchor">#</a> 49.如何将类数组转化为真数组</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>伪数组和真数组的区别： <span class="token number">1.</span> 伪数组可以使用length ，但是不能修改length，可以使用下标取值，但是不能使用数组的其他方法，<span class="token number">2.</span>伪数组是一个对象  遍历使用<span class="token keyword">for</span> <span class="token keyword">in</span>方法


<span class="token comment">//通过call调用数组的slice方法来实现转换</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span>

<span class="token comment">//通过call调用数组的splice方法来实现转换</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token comment">//通过apply调用数组的concat方法来实现转换</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arrayLike<span class="token punctuation">)</span>

<span class="token comment">//通过Array.from方法来实现转换</span>
Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span>
<span class="token comment">//扩展运算符</span>
<span class="token keyword">let</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_50-为什么js是单线程"><a href="#_50-为什么js是单线程" class="header-anchor">#</a> 50.为什么js是单线程</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。
举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变

为了利用多核<span class="token constant">CPU</span>的计算能力，<span class="token constant">HTML5</span>提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作<span class="token constant">DOM</span>。所以，这个新标准并没有改变JavaScript单线程的本质。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_51-说说promise的all和race"><a href="#_51-说说promise的all和race" class="header-anchor">#</a> 51.说说promise的all和race</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>和promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">)</span>接收的都是数组
<span class="token number">1</span><span class="token punctuation">.</span>promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 是当数组中的每一个异步任务返回结果后，才执行后面的代码
应用场景：当我们需要让用户同时看到多个数据的展示时
<span class="token number">2</span><span class="token punctuation">.</span>promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">)</span>是数组中最快的那个异步任务返回结果后，就执行后的代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_52-立即执行函数面试题"><a href="#_52-立即执行函数面试题" class="header-anchor">#</a> 52.立即执行函数面试题</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> 
    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//到这的时候 b被赋值为了这个立即执行函数</span>
      b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>         <span class="token comment">//(b=20)(因为函数表达式特性，标识符无法被修改，所以这里执行失败)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//打印函数</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token comment">//离谱 我现在还不知道原因</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_53-说说for-in-和for-of区别"><a href="#_53-说说for-in-和for-of区别" class="header-anchor">#</a> 53.说说for in 和for of区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>  <span class="token comment">//0 1 2 3 4 5           如果原型上还有的话，也会遍历</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//1,3,4,5,6</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token comment">//不能遍历对象，需要配合Object.keys()</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">//1,3,4,5,6                  //只能获取到数组元素，不能获取索引 </span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token keyword">in</span>遍历的是数组的索引（即键名），而<span class="token keyword">for</span> <span class="token keyword">of</span>遍历的是数组元素值    <span class="token keyword">for</span> <span class="token keyword">in</span>会遍历数组所有的可枚举属性，包括原型
<span class="token keyword">for</span> <span class="token keyword">in</span>总是得到对象的key或数组、字符串的下标
<span class="token keyword">for</span> <span class="token keyword">of</span>总是得到对象的value或数组、字符串的值 <span class="token punctuation">,</span>遍历的只是数组内的元素，不包括原型属性和索引
<span class="token number">1</span><span class="token punctuation">.</span>for <span class="token keyword">of</span> 只能遍历其底层带有lterator接口的数据结构，像<span class="token keyword">set</span>，map string array <span class="token function">等，对于普通对象没有部署原生的lterator</span><span class="token punctuation">(</span>迭代器<span class="token punctuation">)</span>接口，所以直接使用<span class="token keyword">for</span> <span class="token keyword">of</span> 会报错的，因此在项目开发中我们一般使用<span class="token keyword">for</span> <span class="token keyword">in</span> 遍历对象， <span class="token keyword">for</span> <span class="token keyword">in</span> 遍历数组返回的是数组下标，而不是元素，而且遍历顺序有可能不是按照实际数组的内部顺序的，所以我们通常遍历数组用的是<span class="token keyword">for</span> <span class="token keyword">of</span>
<span class="token number">2.</span>普通对象部署迭代器
<span class="token number">2.1</span> 对象转Map 用<span class="token keyword">for</span> <span class="token keyword">in</span> 遍历 普通对象，创建一个Map 实例，给这个实例添加我们普通对象的键和值
<span class="token number">2.2</span> 我记得 <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> 可以部署迭代器
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_54-为什么推荐把script标签放到body底部"><a href="#_54-为什么推荐把script标签放到body底部" class="header-anchor">#</a> 54.为什么推荐把script标签放到body底部</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>如果把script标签放到head标签中的话，会阻塞html的解析，会先下载脚本，运行脚本，导致页面阻塞，另外，如果说脚本里
用到了html dom节点的话，会导致获取不到，报错，整个进程崩溃
<span class="token number">2.</span>放在 body 底部
 html 内容第一时间渲染完成，随后等待 js 的加载。
 浏览器默认设置js线程 和uI渲染线程是互斥的，如果script脚本，放在头部的话，如果js脚本很大的话，下载和解析很长时间，就会导致页  面出现空白
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_55-说一下原生js怎么获取dom元素"><a href="#_55-说一下原生js怎么获取dom元素" class="header-anchor">#</a> 55.说一下原生js怎么获取dom元素</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span>、根据id获取元素
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;id属性的值&quot;</span><span class="token punctuation">)</span>
<span class="token number">2</span>、根据标签名字获取元素
document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">&quot;标签的名字&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">3</span>、根据name属性的值获取元素
document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">&quot;name属性的值&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">4</span>、根据类样式的名字获取元素
document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">&quot;类样式的名字&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">5</span>、根据选择器获取元素
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;选择器&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">&quot;选择器&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_56-说一下es6新特性"><a href="#_56-说一下es6新特性" class="header-anchor">#</a> 56.说一下es6新特性</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>let 和 <span class="token keyword">const</span>
<span class="token number">2</span><span class="token punctuation">.</span>Promise
<span class="token number">3</span><span class="token punctuation">.</span>Class
<span class="token number">4.</span>箭头函数
<span class="token number">5.</span>函数参数默认值
<span class="token number">6.</span>模版字符串
<span class="token number">7.</span>解构赋值
<span class="token number">8.</span>展开语法
<span class="token number">9.</span>构造数组，调用函数时，将数组表达式 或 string 在语法层面展开
<span class="token number">10.</span>对象属性缩写
键名和键值相同
<span class="token number">11.</span>函数省略 <span class="token keyword">function</span>
<span class="token number">12.</span>模块化
<span class="token number">13</span><span class="token punctuation">.</span>Set
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_57-object-assign"><a href="#_57-object-assign" class="header-anchor">#</a> 57.Object.assign()</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>Object的静态方法，用于浅拷贝，和vue2缺陷，对对象，新增的属性没有响应式
<span class="token keyword">this</span><span class="token punctuation">.</span>someObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>someObject<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_58-break-return-continue的区别"><a href="#_58-break-return-continue的区别" class="header-anchor">#</a> 58.break return continue的区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span>、<span class="token keyword">return</span> ：直接跳出当前的方法<span class="token punctuation">,</span>返回到该调用的方法的语句处<span class="token punctuation">,</span>继续执行
<span class="token number">2</span>、<span class="token keyword">break</span>：在循环体内结束整个循环过程
<span class="token number">3</span>、<span class="token keyword">continue</span> ：结束本次的循环，直接进行下一次的循环
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_59-为什么-0-1-0-2-0-3"><a href="#_59-为什么-0-1-0-2-0-3" class="header-anchor">#</a> 59.为什么 0.1+0.2!=0.3</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>在做算术运算时，<span class="token constant">JS</span> 会先把十进制数转换成二进制数后再计算，十进制小数转二进制数的方式是 x <span class="token number">2</span> 取整，<span class="token number">0.1</span> 和 <span class="token number">0.2</span> 的二进制数是个无限循环小数   计算机是通过二进制的方式存储数据的，所以计算机计算<span class="token number">0.1</span><span class="token operator">+</span><span class="token number">0.2</span>的时候，实际上是计算的两个数的二进制的和。<span class="token number">0.1</span>的二进制是<span class="token number">0.0001100110011001100</span><span class="token operator">...</span>（<span class="token number">1100</span>循环），<span class="token number">0.2</span>的二进制是：<span class="token number">0.00110011001100</span><span class="token operator">...</span>（<span class="token number">1100</span>循环）  二进制相加，再转化为十进制数就是：<span class="token number">0.30000000000000004</span>。
<span class="token literal-property property">解决办法</span><span class="token operator">:</span> <span class="token number">1.</span>可以把小数转化为整数再计算
         <span class="token number">2.</span>可以使用一些库，如 <span class="token function">Decimal</span><span class="token punctuation">(</span>day c bo<span class="token punctuation">)</span><span class="token punctuation">.</span>js、big<span class="token punctuation">.</span>js <span class="token function">等</span> <span class="token punctuation">(</span>在进行精度要求较高的计算时，建议使用<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_60-数组里面有2w个元素-取第一个元素和最后一个元素的时间相差多少"><a href="#_60-数组里面有2w个元素-取第一个元素和最后一个元素的时间相差多少" class="header-anchor">#</a> 60.数组里面有2w个元素，取第一个元素和最后一个元素的时间相差多少？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 <span class="token constant">O</span><span class="token punctuation">(</span><span class="token parameter"><span class="token number">1</span></span><span class="token punctuation">)</span>
<span class="token operator">=&gt;</span> 消耗时间几乎一致，差异可以忽略不计
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_61-es6-代码转成-es5-代码的实现思路是什么"><a href="#_61-es6-代码转成-es5-代码的实现思路是什么" class="header-anchor">#</a> 61.ES6 代码转成 ES5 代码的实现思路是什么？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>将<span class="token constant">ES6</span> 转为<span class="token constant">ES5</span> 主要用到的是Babel编译器， 参考Babel的实现方式。
那么 Babel 是如何把 <span class="token constant">ES6</span> 转成 <span class="token constant">ES5</span> 呢，其大致分为三步：
<span class="token number">1.</span>解析：解析代码字符串，生成 <span class="token constant">AST</span><span class="token punctuation">(</span>抽象语法树<span class="token punctuation">)</span>；
<span class="token number">2.</span>转换：按一定的规则转换、修改 <span class="token constant">AST</span>，将<span class="token constant">ES6</span>转换为<span class="token constant">ES5</span>代码；
<span class="token number">3.</span>生成：将修改后的 <span class="token constant">AST</span> 转换成普通代码。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_62-dom和bom区别-以及常用方法"><a href="#_62-dom和bom区别-以及常用方法" class="header-anchor">#</a> 62.DOM和BOM区别，以及常用方法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">DOM</span>的顶级对象是document实际上是window<span class="token punctuation">.</span>document    <span class="token constant">BOM</span>的顶级对象是window
<span class="token constant">DOM</span> 是为了操作文档出现的 <span class="token constant">API</span>
<span class="token constant">BOM</span> 是为了操作浏览器出现的 <span class="token constant">API</span>
<span class="token constant">DOM</span>常用的api ：
<span class="token number">1.</span> 获取元素的方法
<span class="token number">2.</span>事件 事件对象  事件注册
<span class="token number">3.</span>自定义属性
<span class="token number">4.</span>节点操作
<span class="token constant">BOM</span>常用的api：
<span class="token number">1.</span>定时器
<span class="token number">2</span><span class="token punctuation">.</span>scroll事件 resize事件
<span class="token number">3</span><span class="token punctuation">.</span>offset 元素偏移量
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_63-说一下es6的新特性"><a href="#_63-说一下es6的新特性" class="header-anchor">#</a> 63.说一下es6的新特性</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> <span class="token keyword">let</span> <span class="token keyword">const</span>  <span class="token comment">//解决了变量提升，变量污染问题</span>
<span class="token number">2.</span>箭头函数
<span class="token number">3.</span>解构
<span class="token number">4.</span>剩余参数  <span class="token comment">//必须写在参数的最后一个 ，否则会报错</span>
<span class="token number">5</span><span class="token punctuation">.</span>Set Map
<span class="token number">6.</span>模板字符串 <span class="token comment">//支持换行 空格、缩进、，使用变量${} ，解决了es6之前的变量拼接繁琐问题</span>
<span class="token number">7</span><span class="token punctuation">.</span>promise
<span class="token number">8</span><span class="token punctuation">.</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">9.</span>允许直接在对象中写变量，这是变量既是属性名也是属性值，一种对象键值的简写
<span class="token number">10.</span>函数的扩展，函数可以给参数提供默认值
<span class="token number">11</span><span class="token punctuation">.</span>for <span class="token keyword">of</span> 循环
<span class="token number">12</span><span class="token punctuation">.</span>import <span class="token keyword">export</span>
<span class="token number">13</span><span class="token punctuation">.</span>Set数据结构
<span class="token number">14</span><span class="token punctuation">.</span>class类
<span class="token number">15</span><span class="token punctuation">.</span>Symbol
<span class="token number">16</span><span class="token punctuation">.</span>Proxy
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_64-super-继承"><a href="#_64-super-继承" class="header-anchor">#</a> 64.super 继承</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>   <span class="token comment">// 定义一个子类，继承父类</span>
    <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
      <span class="token comment">// 1. super() 必须在子类的this前面调用</span>
      <span class="token comment">// 2. super() 代表了父类的构造函数</span>
      <span class="token comment">// 3. super() 里面的this 指向的是谁呢？</span>
      <span class="token comment">//  ===&gt; 指向的是子类的实例，Son的实例 p这个对象</span>
      <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">// ==&gt; super(x, y)  父类的constructor(x, y)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color

      <span class="token punctuation">}</span>
      <span class="token comment">// 4. 怎么理解super()要在this前面调用？</span>
      <span class="token comment">// 我们现在是不是在实现继承，让子类拥有父类的属性和方法</span>
      <span class="token comment">// 我们需要先继承父类的属性和方法，然后再扩展自己的属性和方法。</span>
    <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="_65-说一下promise是什么以及使用方法"><a href="#_65-说一下promise是什么以及使用方法" class="header-anchor">#</a> 65.说一下promise是什么以及使用方法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//这题可以多说说自己在项目中是如何运用 promise 的</span>
<span class="token number">1</span><span class="token punctuation">.</span>Promise本身是同步的立即执行函数，当执行了resolve或reject时的<span class="token punctuation">.</span>then和<span class="token punctuation">.</span>catch的回调是异步微任务，解决了异步多层嵌套回调的问题，让代码的可读性更高，更容易维护
<span class="token number">2.</span>使用Promise构造函数<span class="token keyword">new</span>一个实例，Promise构造函数接收一个函数作为参数，这个函数有两个参数，分别是两个函数 <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">resolve</span><span class="token template-punctuation string">`</span></span>和<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">reject</span><span class="token template-punctuation string">`</span></span>，<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">resolve</span><span class="token template-punctuation string">`</span></span>将Promise的状态由等待变为成功，将异步操作的结果作为参数传递过去；<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">reject</span><span class="token template-punctuation string">`</span></span>则将状态由等待转变为失败，在异步操作失败时调用，将异步操作报出的错误作为参数传递过去。实例创建完成后，可以使用<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">then</span><span class="token template-punctuation string">`</span></span>方法分别指定成功或失败的回调函数，也可以使用catch捕获失败，then和catch最终返回的也是一个Promise，所以可以链式调用。
<span class="token number">3</span><span class="token punctuation">.</span>Promise有三种状态 <span class="token number">1</span><span class="token punctuation">.</span>pending（执行中）为初始状态 <span class="token number">2</span><span class="token punctuation">.</span>Resolved（成功<span class="token punctuation">)</span> <span class="token number">3.</span> rejected（失败）   Resolved 和rejected为结束状态
（结束状态表示promise的生命周期已结束）  resolve 方法的参数是then中回调函数的参数，reject 方法中的参数是catch中的参数 <span class="token number">4.</span> then 方法和 catch方法 只要不报错，返回的都是一个成功状态的promise
<span class="token number">4</span><span class="token punctuation">.</span>promise的其他方法
 <span class="token number">4.1</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span>返回的Promise对象状态为成功的，并且将该value传递给对应的then方法。 
 <span class="token number">4.2</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的catch或<span class="token punctuation">.</span>then的第二个参数。
 <span class="token number">4.3</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：返回一个新的promise对象，该promise对象在参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。 
 <span class="token number">4.4</span> Promise<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。
 <span class="token number">4.5</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">)</span>：当参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应的<span class="token punctuation">.</span>then 或<span class="token punctuation">.</span>catch，并返回该promise对象。
<span class="token number">5.</span> <span class="token keyword">async</span> <span class="token keyword">await</span> 是promise的语法糖
<span class="token keyword">async</span>意为异步，<span class="token keyword">await</span>意为等待  为优化then链而开发出来的
<span class="token keyword">async</span>函数会返回一个promise ，如果<span class="token keyword">async</span>函数内部没有<span class="token keyword">return</span> 则promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的参数就是<span class="token keyword">undefined</span>，如果有返回值的话，参数就是<span class="token keyword">async</span>函数<span class="token keyword">return</span>后面的对象，如果不用<span class="token keyword">await</span>的话，就用<span class="token punctuation">.</span>then获取对应的值，用<span class="token keyword">await</span>的话，<span class="token keyword">await</span>则是在等待<span class="token keyword">async</span>函数的返回值，<span class="token operator">-</span> 如果它等到的不是一个 Promise 对象，那 <span class="token keyword">await</span> 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 <span class="token keyword">await</span> 表达式的运算结果。
<span class="token number">6.</span><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法返回一个 Promise。在 promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数	
缺陷：
<span class="token operator">-</span> 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
<span class="token operator">-</span> 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
<span class="token operator">-</span> 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

promise<span class="token punctuation">.</span>then和<span class="token keyword">await</span>的区别
Async<span class="token operator">/</span>Await与Promise最大区别在于：<span class="token keyword">await</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>会暂停所在的<span class="token keyword">async</span>函数的执行；而Promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>将b函数加入回调链中之后，会继续执行当前函数。对于堆栈来说，这个不同点非常关键。
<span class="token comment">//Promise 的使用场景包括：</span>
<span class="token number">1.</span>处理异步操作：比如 Ajax 请求、文件读取等。
<span class="token number">2.</span>优化回调函数：将回调函数转换成 Promise 链，提高代码可读性。
<span class="token number">3.</span>实现并发请求：Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 可以让多个请求并行执行。
<span class="token number">4.</span>解决回调地狱：将嵌套的回调函数转换成链式调用，提高代码可读性。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="_66-js实现异步的方法"><a href="#_66-js实现异步的方法" class="header-anchor">#</a> 66.js实现异步的方法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>回调函数、事件监听、setTimeout、Promise、生成器Generators<span class="token operator">/</span><span class="token keyword">yield</span>、 async <span class="token operator">/</span><span class="token keyword">await</span> 
所有异步任务都是在同步任务执行结束之后，从任务队列中依次取出执行。
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> gen <span class="token operator">=</span> <span class="token function">generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 1, done: false }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 2, done: false }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: 3, done: false }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value: undefined, done: true }</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_67-数组去重的方法"><a href="#_67-数组去重的方法" class="header-anchor">#</a> 67.数组去重的方法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>利用对象，遍历需要去重的数组，如果对象中key没有数组的元素，就添加到对象中，并且新创一个数组，push到新数组中，其实可以不用创建新数组来接收去重后的数组，直接可以用Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> 直接得到去重后的数组
<span class="token number">2.</span> 利用<span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  ：利用Set类型数据无重复项：<span class="token keyword">new</span> 一个 Set，参数为需要去重的数组，Set 会自动删除重复的元素，再将 Set 转为数组返回
<span class="token number">3.</span>利用 filter <span class="token operator">+</span> indexOf  原理就是 indexOf 会返回最先找到的数字的索引   <span class="token keyword">return</span>  index <span class="token operator">===</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
<span class="token number">4</span><span class="token punctuation">.</span>reduce <span class="token operator">+</span>includes去重：这个方法就是利用reduce遍历和传入一个空数组作为去重后的新数组，然后内部判断新数组中是否存在当前遍历的元素，不存在就插入到新数组中

在数据低于<span class="token number">10000</span>条的时候没有明显的差别，高于<span class="token number">10000</span>条，第一种和第二种的时间消耗最少，后面三种时间消耗依次增加，由于第一种内存空间消耗比较多，且现在很多项目不再考虑低版本浏览器的兼容性问题，所以建议使用第二种去重方法，简洁方便。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_68-说一下js-变量提升"><a href="#_68-说一下js-变量提升" class="header-anchor">#</a> 68.说一下js 变量提升</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>js执行一段代码，变量提升是指<span class="token constant">JS</span>的变量和函数声明会在代码编译期，提升到代码的最前面。 变量提升成立的前提是使用Var关键字进行声明的变量，并且变量提升的时候只有声明被提升，赋值并不会被提升，同时函数的声明提升会比变量的提升优先。 变量提升的结果，可以在变量初始化之前访问该变量，返回的是<span class="token keyword">undefined</span>。在函数声明前可以调用该函数。 加分回答 使用<span class="token keyword">let</span>和<span class="token keyword">const</span>声明的变量是创建提升，形成暂时性死区，在初始化之前访问<span class="token keyword">let</span>和<span class="token keyword">const</span>创建的变量会报错
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_69-map和foreach的区别"><a href="#_69-map和foreach的区别" class="header-anchor">#</a> 69.map和forEach的区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>map 不会改变原数组，返回一个新数组，map的处理速度比forEach快，由于可以返回一个新数组，可以链接调用其他数组方法
<span class="token number">2</span><span class="token punctuation">.</span>forEach 默认无返回值，返回值是<span class="token keyword">undefined</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_70-说一下fetch-请求方式"><a href="#_70-说一下fetch-请求方式" class="header-anchor">#</a> 70.说一下fetch 请求方式？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code> fetch是一种<span class="token constant">HTTP</span>数据请求的方式，是XMLHttpRequest的一种替代方案。、头部信息、请求信息、响应信息等均分布到不同的对象<span class="token punctuation">,</span><span class="token function">Fetch函数就是原生js，没有使用XMLHttpRequest对象。fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法返回一个Promise解析Response来自Request显示状态（成功与否）的方法。
 XMLHttpRequest的问题 <span class="token operator">-</span>所有的功能全部集中在一个对象上<span class="token punctuation">,</span> 容易书写出混乱而且不容易维护的代码 
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://example.com/movies.json'</span><span class="token punctuation">)</span>	
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_80-说一下js数据类型的隐式转换呢"><a href="#_80-说一下js数据类型的隐式转换呢" class="header-anchor">#</a> 80.说一下js数据类型的隐式转换呢</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 当运算符是<span class="token operator">/</span> <span class="token operator">*</span><span class="token operator">-</span>都会隐式转化为number数据类型 ，如果 <span class="token operator">+</span>str  则str也会隐式转换为number， 如果 <span class="token operator">+</span> 操作符的两侧没有字符串，则也会隐式转化number ，如果两侧有一个字符串，则会执行字符串相连的操作
<span class="token number">2.</span> <span class="token operator">==</span> 会隐式转化数据类型 ，js尽量把操作符两边的值转化为number
<span class="token number">3.</span> 对于 <span class="token operator">&lt;</span> 和 <span class="token operator">&gt;</span> <span class="token punctuation">,</span>  两种情况： <span class="token number">3.1</span> <span class="token punctuation">.</span> 第一种<span class="token operator">:</span>如果操作符的两侧都是字符串，则会比较字母表的顺序  <span class="token number">3.2</span><span class="token punctuation">.</span>第二种<span class="token operator">:</span>其他情况都是转为数字再比较

ToPrimitive方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：
<span class="token comment">/**
* @obj 需要转换的对象
* @type 期望的结果类型
*/</span>
<span class="token function">ToPrimitive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>type<span class="token punctuation">)</span>
<span class="token number">1.</span>当type为number 时，
首先会调用 obj<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 如果为基本数据类型，则返回，反之调用 obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">2.</span>当type为string时规则如下：
调用obj的toString方法，如果为原始值，则返回，否则下一步；
调用obj的valueOf方法，后续同上；
可以看出两者的主要区别在于调用toString和valueOf的先后顺序。默认情况下：
如果对象为 Date 对象，则type默认为string；
其他情况下，type默认为number。
总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：
<span class="token keyword">var</span> <span class="token function-variable function">objToNumber</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token function">Number</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">objToNumber</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">===</span><span class="token operator">&gt;</span> <span class="token number">0</span>    <span class="token number">1.</span><span class="token function">Number</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">objToNumber</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">===</span><span class="token operator">&gt;</span> <span class="token number">NaN</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="_81-并发与并行的区别"><a href="#_81-并发与并行的区别" class="header-anchor">#</a> 81.并发与并行的区别？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>并发是宏观概念，我分别有任务 <span class="token constant">A</span> 和任务 <span class="token constant">B</span>，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。
并行是微观概念，假设 <span class="token constant">CPU</span> 中存在两个核心，那么我就可以同时完成任务 <span class="token constant">A</span>、<span class="token constant">B</span>。同时完成多个任务的情况就可以称之为并行。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_82-多维数组降维的方法"><a href="#_82-多维数组降维的方法" class="header-anchor">#</a> 82.多维数组降维的方法</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
方法<span class="token number">1.</span> 数组字符串化
<span class="token number">1.</span> <span class="token keyword">const</span> str <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// '1 3 4 5'</span>
   <span class="token keyword">const</span> newArr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
方法二<span class="token punctuation">.</span> flat方法
<span class="token number">2</span><span class="token punctuation">.</span>const newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span>   参数是扁平多少层数组，当参数是 <span class="token number">Infinity</span> 时，扁平为一维数组
方法三<span class="token punctuation">.</span> 递归
<span class="token number">3.</span> <span class="token keyword">const</span> newArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 
<span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
      newArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_83-如何合并对个数组-对象"><a href="#_83-如何合并对个数组-对象" class="header-anchor">#</a> 83.如何合并对个数组，对象？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//合并多个对象</span>
<span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">&quot;嘻嘻&quot;</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span>
<span class="token number">1.</span>循环
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> obj1<span class="token punctuation">)</span><span class="token punctuation">{</span>
obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>obj1<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> obj2<span class="token punctuation">)</span><span class="token punctuation">{</span>
obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">=</span>obj2<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token number">2.</span>扩展运算符
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>obj1 <span class="token punctuation">,</span> <span class="token operator">...</span>obj2 <span class="token punctuation">}</span>
<span class="token number">3</span><span class="token punctuation">.</span>const obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>obj1<span class="token punctuation">,</span>obj2<span class="token punctuation">)</span>
<span class="token comment">//多个数组的合并</span>
<span class="token keyword">const</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token number">1.</span>扩展运算符
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arr1<span class="token punctuation">,</span><span class="token operator">...</span>arr2<span class="token punctuation">]</span>
<span class="token number">2.</span>数组的concat方法
<span class="token keyword">const</span> arr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span>arr2<span class="token punctuation">)</span>
<span class="token number">3.</span>循环
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
arr1<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token operator">=&gt;</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">)</span>
arr2<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token operator">=&gt;</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="_84-知道lodash吗-它有哪些常见的api"><a href="#_84-知道lodash吗-它有哪些常见的api" class="header-anchor">#</a> 84.知道lodash吗？它有哪些常见的API ？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。
_<span class="token punctuation">.</span>cloneDeep 深度拷贝
_<span class="token punctuation">.</span>reject 根据条件去除某个元素。
_<span class="token punctuation">.</span><span class="token function">drop</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token punctuation">[</span>n<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> 作用：将 array 中的前 n 个元素去掉，然后返回剩余的部分<span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_85-知道symbol-吗"><a href="#_85-知道symbol-吗" class="header-anchor">#</a> 85.知道symbol 吗？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">ES6</span> 引入新的原始数据类型Symbol，表示独一无二的值 <span class="token punctuation">,</span>用途，一般给对象添加属性的时候，用Symbol返回一个独一无二的属性名
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_86-请描述一下es6中的class类"><a href="#_86-请描述一下es6中的class类" class="header-anchor">#</a> 86.请描述一下ES6中的class类?</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>es6中的<span class="token keyword">class</span>可以把它看成是es5中构造函数的语法糖，它简化了构造函数的写法， 类的共有属性放到
constructor 里面
<span class="token number">1.</span> 通过<span class="token keyword">class</span> 关键字创建类<span class="token punctuation">,</span> 类名我们还是习惯性定义首字母大写
<span class="token number">2.</span> 类里面有个constructor 函数<span class="token punctuation">,</span>可以接受传递过来的参数<span class="token punctuation">,</span>同时返回实例对象
<span class="token number">3.</span> constructor 函数 只要 <span class="token keyword">new</span> 生成实例时<span class="token punctuation">,</span>就会自动调用这个函数<span class="token punctuation">,</span> 如果我们不写这个函数<span class="token punctuation">,</span>类也会自
动生成这个函数
<span class="token number">4.</span> 多个函数方法之间不需要添加逗号分隔
<span class="token number">5.</span> 生成实例 <span class="token keyword">new</span> 不能省略
<span class="token number">6.</span> 语法规范<span class="token punctuation">,</span> 创建类 类名后面不要加小括号<span class="token punctuation">,</span>生成实例 类名后面加小括号<span class="token punctuation">,</span> 构造函数不需要加<span class="token keyword">function</span>
<span class="token number">1.</span> 继承中<span class="token punctuation">,</span>如果实例化子类输出一个方法<span class="token punctuation">,</span>先看子类有没有这个方法<span class="token punctuation">,</span>如果有就先执行子类的
<span class="token number">2.</span> 继承中<span class="token punctuation">,</span>如果子类里面没有<span class="token punctuation">,</span>就去查找父类有没有这个方法<span class="token punctuation">,</span>如果有<span class="token punctuation">,</span><span class="token function">就执行父类的这个方法</span><span class="token punctuation">(</span>就近
原则<span class="token punctuation">)</span>
<span class="token number">3.</span> 如果子类想要继承父类的方法<span class="token punctuation">,</span>同时在自己内部扩展自己的方法<span class="token punctuation">,</span>利用<span class="token keyword">super</span> 调用 父类的构造函
数<span class="token punctuation">,</span><span class="token keyword">super</span> 必须在子类<span class="token keyword">this</span>之前调用
<span class="token number">7.</span> 时刻注意<span class="token keyword">this</span>的指向问题<span class="token punctuation">,</span>类里面的共有的属性和方法一定要加<span class="token keyword">this</span>使用<span class="token punctuation">.</span>
<span class="token number">1.</span> constructor中的<span class="token keyword">this</span>指向的是<span class="token keyword">new</span>出来的实例对象
<span class="token number">2.</span> 自定义的方法<span class="token punctuation">,</span>一般也指向的<span class="token keyword">new</span>出来的实例对象
<span class="token number">3.</span> 绑定事件之后<span class="token keyword">this</span>指向的就是触发事件的事件源
<span class="token number">4.</span> 在 <span class="token constant">ES6</span> 中类没有变量提升，所以必须先定义类，才能通过类实例化对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_87-cookie和session-的区别"><a href="#_87-cookie和session-的区别" class="header-anchor">#</a> 87.cookie和session 的区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span>、cookie数据存放在客户的浏览器上，session数据放在服务器上。
<span class="token number">2</span>、cookie不是很安全，别人可以分析存放在本地的<span class="token constant">COOKIE</span>并进行<span class="token constant">COOKIE</span>欺骗
考虑到安全应当使用session。
<span class="token number">3</span>、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
考虑到减轻服务器性能方面，应当使用<span class="token constant">COOKIE</span>。
<span class="token number">4</span>、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存<span class="token number">20</span>个cookie。
<span class="token number">5</span>、所以个人建议：
将登陆信息等重要信息存放为<span class="token constant">SESSION</span>
其他信息如果需要保留，可以放在<span class="token constant">COOKIE</span>中
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_88-如何获取数组中最后一个元素"><a href="#_88-如何获取数组中最后一个元素" class="header-anchor">#</a> 88.如何获取数组中最后一个元素</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.9999</span><span class="token punctuation">]</span>
<span class="token number">1.</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">2.</span> <span class="token keyword">const</span> res <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//通过pop是删除最后一个元素，且会返回最后一个元素，res就是我们想要的到的数据</span>
<span class="token comment">//如果只是不仅仅获取数组最后一个数据，而且最后一个数据还有用的话，我们就需要把原数组深拷贝一份</span>
<span class="token number">3</span><span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//代表从数组的最后一个元素截取，当不传第二个方法时，表示一直截取到数组的末尾，返回一个新数组，而这个新数组就包含了我们想要取的数组的最后一个元素了</span>
<span class="token number">4</span><span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> 返回传入得索引值的元素，如果是<span class="token operator">-</span><span class="token number">1</span>，则会返回最后一个元素
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_89-说一下echarts使用的基本步骤"><a href="#_89-说一下echarts使用的基本步骤" class="header-anchor">#</a> 89.说一下echarts使用的基本步骤</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 1. 下载并引入echarts 文件</span>
<span class="token comment">// 2. 为 echarts 准备一个定义了宽高的 DOM</span>
<span class="token comment">// 3. 基于准备好的DOM， 初始化echarts 实例</span>
<span class="token comment">// 4. 指定图表的配置项和数据</span>
<span class="token comment">// 5. 将配置项设置给echarts实例对象 （通过setOption）</span>

具体步骤 
<span class="token number">1.</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token number">1.</span> 引入echarts <span class="token operator">--</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;./js/echarts.min.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token number">2.</span><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token number">2.</span> 准备一个定义了宽高的<span class="token constant">DOM</span> <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;echart-box&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;echart-bar&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token number">3.</span><span class="token comment">// 3. 初始化echarts实例</span>
<span class="token keyword">const</span> myChart <span class="token operator">=</span> echarts<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.echart-box'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">4.</span><span class="token comment">// 4. 指定图表的配置项和数据</span>
<span class="token keyword">const</span> option <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">'ECharts 入门示例'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">tooltip</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">legend</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'销量'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">xAxis</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'衬衫'</span><span class="token punctuation">,</span> <span class="token string">'羊毛衫'</span><span class="token punctuation">,</span> <span class="token string">'雪纺衫'</span><span class="token punctuation">,</span> <span class="token string">'裤子'</span><span class="token punctuation">,</span> <span class="token string">'高跟鞋'</span><span class="token punctuation">,</span> <span class="token string">'袜子'</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">yAxis</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">series</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'销量'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token number">5.</span><span class="token comment">// 5. 使用刚指定的配置项和数据显示图表挂载到echarts实例上。</span>
myChart<span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">6.</span><span class="token comment">//echarts图表的适配</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'resize'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      myChart<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token comment">//echarts实例上有一个方法能实现适配，resize</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><h2 id="_90-为什么会有bigint提案"><a href="#_90-为什么会有bigint提案" class="header-anchor">#</a> 90.为什么会有Bigint提案</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>JavaScript中Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span>表示最大安全数字，计算结果是<span class="token number">9007199254740991</span>，当进行运算时即在这个数范围内不会出现精度丢失（小数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。
BigInt 可以表示任意大的整数
可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：<span class="token number">10n</span>，或者调用函数 <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>（但不包含 <span class="token keyword">new</span> 运算符）并传递一个整数值或字符串值。
不能和任何 Number 实例混合运算，两者必须转换成同一种类型。
当使用 BigInt 时，带小数的运算会被取整。
<span class="token keyword">const</span> expected <span class="token operator">=</span> <span class="token number">4n</span> <span class="token operator">/</span> <span class="token number">2n</span><span class="token punctuation">;</span>
<span class="token comment">// ↪ 2n</span>
<span class="token keyword">const</span> rounded <span class="token operator">=</span> <span class="token number">5n</span> <span class="token operator">/</span> <span class="token number">2n</span><span class="token punctuation">;</span>
<span class="token comment">// ↪ 2n, not 2.5n</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_91-javascript脚本延迟加载的方式有哪些"><a href="#_91-javascript脚本延迟加载的方式有哪些" class="header-anchor">#</a> 91.JavaScript脚本延迟加载的方式有哪些？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> <span class="token operator">**</span>defer 属性：<span class="token operator">**</span>给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
<span class="token number">2.</span> <span class="token operator">**</span><span class="token keyword">async</span> 属性：<span class="token operator">**</span>给 js 脚本添加 <span class="token keyword">async</span> 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 <span class="token keyword">async</span> 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
<span class="token number">3.</span> <span class="token operator">**</span>动态创建 <span class="token constant">DOM</span> 方式：<span class="token operator">**</span>动态创建 <span class="token constant">DOM</span> 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。
<span class="token number">4.</span><span class="token operator">**</span>使用 setTimeout 延迟方法：<span class="token operator">**</span>设置一个定时器来延迟加载js脚本文件
<span class="token number">5.</span><span class="token operator">**</span>让 <span class="token constant">JS</span> 最后加载：<span class="token operator">**</span>将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_92-什么是尾调用-使用尾调用有什么好处"><a href="#_92-什么是尾调用-使用尾调用有什么好处" class="header-anchor">#</a> 92.什么是尾调用，使用尾调用有什么好处？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 <span class="token constant">ES6</span> 的尾调用优化只在严格模式下开启，正常模式是无效的
<span class="token number">2.</span>尾递归指的是函数在最后一步自己调用自己，好处是，只会创建一个当前函数执行上下文，不会有栈溺出的问题
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_93-es6-module和commonjs模块的区别"><a href="#_93-es6-module和commonjs模块的区别" class="header-anchor">#</a> 93.ES6 Module和CommonJS模块的区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>CommonJs
<span class="token number">1</span><span class="token punctuation">.</span>module<span class="token punctuation">.</span>exports导出变量及函数，也可以导出任意类型的值
<span class="token number">2</span><span class="token punctuation">.</span>CommonJs中使用require语法可以导入，导入的值是一个对象 如果想要单个的值，可以通过解构对象来获取。
<span class="token number">3</span><span class="token punctuation">.</span>CommonJs支持动态导入，什么意思呢，就是可以在语句中，使用require语法
<span class="token keyword">let</span> lists <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;./index.js&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;./config.js&quot;</span><span class="token punctuation">]</span>
lists<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">require</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 动态导入</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>lists<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">require</span><span class="token punctuation">(</span>lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 动态导入</span>
<span class="token punctuation">}</span>
<span class="token number">4</span><span class="token punctuation">.</span>CommonJs导入的值是拷贝的，所以可以修改拷贝值，但这会引起变量污染，一不小心就重名
<span class="token comment">// index.js</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    num<span class="token punctuation">,</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token operator">++</span> num 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> num<span class="token punctuation">,</span> add <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./index.js&quot;</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">// 0</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token comment">// 0</span>
num <span class="token operator">=</span> <span class="token number">10</span>
Es Module 基本语法
<span class="token number">1</span><span class="token punctuation">.</span>es module 的导出分为两种，默认导出，和按需导出， 默认导出是，<span class="token keyword">export</span> <span class="token keyword">default</span>  使用默认导出的值时，<span class="token keyword">import</span> 变量名 <span class="token keyword">from</span> <span class="token string">'路径'</span> ，按需导出，直接在需要导出的变量前面加上 <span class="token keyword">export</span>，导入的时候，需要加大括号 <span class="token keyword">import</span> <span class="token punctuation">{</span>变量名<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'路径'</span>
<span class="token number">2.</span>如果导出里面全是单个导出，我们可以 用 <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> all  <span class="token keyword">from</span> <span class="token string">'路径'</span> 全部导出， 这时，all就是我们导出变量的一个集合
<span class="token number">3.</span>混合导入，则该文件内用到混合导入，<span class="token keyword">import</span>语句必须先是默认导出，后面再是单个导出，顺序一定要正确否则报错。
<span class="token number">4</span><span class="token punctuation">.</span>export导出的值是值的引用，并且内部有映射关系，这是<span class="token keyword">export</span>关键字的作用。而且导入的值，不能进行修改也就是只读状态
<span class="token number">5</span><span class="token punctuation">.</span>es module 是静态的  就是Es Module语句<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span><span class="token keyword">import</span>只能声明在该文件的最顶部，不能动态加载语句，Es Module`语句运行在代码编译时
共同点： CommonJS和<span class="token constant">ES6</span> Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h2 id="_94-介绍一下-js-中-settimeout-的运行机制"><a href="#_94-介绍一下-js-中-settimeout-的运行机制" class="header-anchor">#</a> 94.介绍一下 JS 中 setTimeout 的运行机制？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>在 JavaScript <span class="token function">中，setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">方法被用于在指定的时间间隔后执行一个指定的代码块。它接受两个参数：第一个参数是需要执行的代码块，第二个参数是代码块的延迟时间（以毫秒为单位）。setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法执行完毕后，代码块将被推入 JavaScript 的执行队列中，等待 JavaScript 引擎在一段时间后执行。

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法具有异步的特性，因此即使 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法指定了一个很短的时间，它也不会在调用代码之后立即执行。相反，它会将代码块放在事件队列的末尾，直到事件队列中没有任何待处理的任务，才会执行。因此，当代码块执行时，当前执行的上下文（也称为堆栈）已经被清空。

如果 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法在代码块执行之前被清除或者代码块执行时间过长，那么代码块将会在 JavaScript <span class="token function">引擎空闲时尽快被执行。因此，setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法不是一个精确的时间控制器，而是一个粗略的时间控制器。如果需要更精确的时间控制器，可以考虑使用 <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 或 Web Workers。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_95-js-如何顺序执行-10-个异步任务"><a href="#_95-js-如何顺序执行-10-个异步任务" class="header-anchor">#</a> 95.JS 如何顺序执行 10 个异步任务？</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>Promise 中的<span class="token punctuation">.</span><span class="token function">then的链式调用，在上一个异步任务执行完之后再调用resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，这时下一个<span class="token punctuation">.</span>then才会执行
<span class="token number">2</span><span class="token punctuation">.</span>async <span class="token keyword">await</span> 
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">runAsyncTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token function">asyncTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> <span class="token function">asyncTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 执行完异步任务1和异步任务2后的逻辑</span>
<span class="token punctuation">}</span>
<span class="token function">runAsyncTasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">3.</span>生成器的方式 <span class="token comment">//不知道是啥任务，反正在微任务和宏任务之后(setTimeout的时间是0的情况)</span>
生成器就是能返回一个迭代器的函数，它也是一个函数，对比普通的函数，多了一个<span class="token operator">*</span>，在它的函数体内可以使用<span class="token keyword">yield</span>关键字<span class="token punctuation">,</span>函数会在每个<span class="token keyword">yield</span><span class="token function">后暂停，等待，直到这个生成的对象，调用下一个next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>每调用一次next会往下执行一次yieId，然后暂停。
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> res1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token string">'开始'</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fn2</span><span class="token punctuation">(</span>res1<span class="token punctuation">)</span>
    <span class="token keyword">const</span> res3 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fn3</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res3<span class="token punctuation">,</span> <span class="token string">'全部执行完毕'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> task <span class="token operator">=</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
task<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn1执行'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
        task<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'fn1执行完毕'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn2执行'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
        task<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'fn2执行完毕'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">fn3</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn3执行'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
        task<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'fn3执行完毕'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是最开始同步执行的'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><h2 id="_96-map-和-weakmap-的区别"><a href="#_96-map-和-weakmap-的区别" class="header-anchor">#</a> 96.Map 和 WeakMap 的区别</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Map 的键可以是任意类型，WeakMap 只接受对象作为键（<span class="token keyword">null</span>除外），不接受其他类型的值作为键
Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键； WeakMap 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的
Map 可以被遍历， WeakMap 不能被遍历
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_97-typeof不能判断数组-如何加一个条件达到我们判断的要求"><a href="#_97-typeof不能判断数组-如何加一个条件达到我们判断的要求" class="header-anchor">#</a> 97.typeof不能判断数组，如何加一个条件达到我们判断的要求</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>判断是否有数组的方法
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></div></div> <!----> <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/myblog/pages/828be1/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">css面试题大全</div></a> <a href="/myblog/pages/307985/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">vue2面试题大全</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/myblog/pages/828be1/" class="prev">css面试题大全</a></span> <span class="next"><a href="/myblog/pages/307985/">vue2面试题大全</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/myblog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/myblog/" class="router-link-active"><div>
            首页
            <!----></div></a> <span class="date"></span></dt></dl><dl><dd>02</dd> <dt><a href="/myblog/pages/94b8d4/"><div>
            setTimeout是怎么实现的
            <!----></div></a> <span class="date">07-07</span></dt></dl><dl><dd>03</dd> <dt><a href="/myblog/pages/0d2221/"><div>
            v8是怎样执行一段代码的
            <!----></div></a> <span class="date">07-07</span></dt></dl> <dl><dd></dd> <dt><a href="/myblog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/myblog/assets/js/app.20d60f97.js" defer></script><script src="/myblog/assets/js/2.5c9bfcd5.js" defer></script><script src="/myblog/assets/js/17.c380dd16.js" defer></script>
  </body>
</html>
