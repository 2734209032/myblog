<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器工作原理 | hyh的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="YYY">
    
    <link rel="preload" href="/myblog/assets/css/0.styles.99ff47a3.css" as="style"><link rel="preload" href="/myblog/assets/js/app.86e991b9.js" as="script"><link rel="preload" href="/myblog/assets/js/2.dd8fbd6f.js" as="script"><link rel="preload" href="/myblog/assets/js/3.39ee49ac.js" as="script"><link rel="prefetch" href="/myblog/assets/js/10.a692fbd4.js"><link rel="prefetch" href="/myblog/assets/js/11.08388110.js"><link rel="prefetch" href="/myblog/assets/js/12.9304c561.js"><link rel="prefetch" href="/myblog/assets/js/13.875e3a6f.js"><link rel="prefetch" href="/myblog/assets/js/14.ab4a6449.js"><link rel="prefetch" href="/myblog/assets/js/15.ef10c68f.js"><link rel="prefetch" href="/myblog/assets/js/16.47e9b371.js"><link rel="prefetch" href="/myblog/assets/js/17.7e5bedb7.js"><link rel="prefetch" href="/myblog/assets/js/18.867a9263.js"><link rel="prefetch" href="/myblog/assets/js/19.262467ab.js"><link rel="prefetch" href="/myblog/assets/js/20.75e64baf.js"><link rel="prefetch" href="/myblog/assets/js/21.6d5140dd.js"><link rel="prefetch" href="/myblog/assets/js/22.93df3f05.js"><link rel="prefetch" href="/myblog/assets/js/23.489f97d2.js"><link rel="prefetch" href="/myblog/assets/js/24.26faffd1.js"><link rel="prefetch" href="/myblog/assets/js/25.24c29789.js"><link rel="prefetch" href="/myblog/assets/js/26.55467329.js"><link rel="prefetch" href="/myblog/assets/js/27.4ee20d4a.js"><link rel="prefetch" href="/myblog/assets/js/28.c0b00ac6.js"><link rel="prefetch" href="/myblog/assets/js/29.035e723a.js"><link rel="prefetch" href="/myblog/assets/js/30.7f225a86.js"><link rel="prefetch" href="/myblog/assets/js/31.2fe01be4.js"><link rel="prefetch" href="/myblog/assets/js/32.76fdc062.js"><link rel="prefetch" href="/myblog/assets/js/33.f56c013e.js"><link rel="prefetch" href="/myblog/assets/js/34.2e1a7181.js"><link rel="prefetch" href="/myblog/assets/js/35.d743471b.js"><link rel="prefetch" href="/myblog/assets/js/36.077f181c.js"><link rel="prefetch" href="/myblog/assets/js/37.d0b5c7d8.js"><link rel="prefetch" href="/myblog/assets/js/38.9cabfb87.js"><link rel="prefetch" href="/myblog/assets/js/39.d22ebb14.js"><link rel="prefetch" href="/myblog/assets/js/4.e647fabc.js"><link rel="prefetch" href="/myblog/assets/js/40.9d424e42.js"><link rel="prefetch" href="/myblog/assets/js/41.ce4ee263.js"><link rel="prefetch" href="/myblog/assets/js/42.cf08eca3.js"><link rel="prefetch" href="/myblog/assets/js/43.84ae1707.js"><link rel="prefetch" href="/myblog/assets/js/44.d84ba1e9.js"><link rel="prefetch" href="/myblog/assets/js/45.79c1ad03.js"><link rel="prefetch" href="/myblog/assets/js/46.2faccb6b.js"><link rel="prefetch" href="/myblog/assets/js/47.f036d8e9.js"><link rel="prefetch" href="/myblog/assets/js/48.03cc22dc.js"><link rel="prefetch" href="/myblog/assets/js/49.4c0377a0.js"><link rel="prefetch" href="/myblog/assets/js/5.ab7fc5be.js"><link rel="prefetch" href="/myblog/assets/js/50.6730761e.js"><link rel="prefetch" href="/myblog/assets/js/51.421c10a9.js"><link rel="prefetch" href="/myblog/assets/js/52.9d64c6f3.js"><link rel="prefetch" href="/myblog/assets/js/53.365bcff0.js"><link rel="prefetch" href="/myblog/assets/js/54.d92d0c4d.js"><link rel="prefetch" href="/myblog/assets/js/55.e9a59a8e.js"><link rel="prefetch" href="/myblog/assets/js/56.38aae51f.js"><link rel="prefetch" href="/myblog/assets/js/57.5e1e990c.js"><link rel="prefetch" href="/myblog/assets/js/58.7ecb1984.js"><link rel="prefetch" href="/myblog/assets/js/59.3c946394.js"><link rel="prefetch" href="/myblog/assets/js/6.e25ccbc3.js"><link rel="prefetch" href="/myblog/assets/js/60.71e29c5d.js"><link rel="prefetch" href="/myblog/assets/js/61.e02109cf.js"><link rel="prefetch" href="/myblog/assets/js/62.84b4ecc3.js"><link rel="prefetch" href="/myblog/assets/js/63.9b9860ad.js"><link rel="prefetch" href="/myblog/assets/js/64.5cb2ea95.js"><link rel="prefetch" href="/myblog/assets/js/65.015e710f.js"><link rel="prefetch" href="/myblog/assets/js/66.36c974d0.js"><link rel="prefetch" href="/myblog/assets/js/67.d8808437.js"><link rel="prefetch" href="/myblog/assets/js/68.66d60f36.js"><link rel="prefetch" href="/myblog/assets/js/69.00a72619.js"><link rel="prefetch" href="/myblog/assets/js/7.7e952e17.js"><link rel="prefetch" href="/myblog/assets/js/70.59e4b15d.js"><link rel="prefetch" href="/myblog/assets/js/71.996c38dd.js"><link rel="prefetch" href="/myblog/assets/js/72.5fce5eb4.js"><link rel="prefetch" href="/myblog/assets/js/73.7a7c6a63.js"><link rel="prefetch" href="/myblog/assets/js/74.c94665e5.js"><link rel="prefetch" href="/myblog/assets/js/75.9bdf7dad.js"><link rel="prefetch" href="/myblog/assets/js/76.791addff.js"><link rel="prefetch" href="/myblog/assets/js/77.fdb935e6.js"><link rel="prefetch" href="/myblog/assets/js/78.28c527d5.js"><link rel="prefetch" href="/myblog/assets/js/79.c9e40709.js"><link rel="prefetch" href="/myblog/assets/js/8.830dd035.js"><link rel="prefetch" href="/myblog/assets/js/80.c0d96193.js"><link rel="prefetch" href="/myblog/assets/js/81.418c0eee.js"><link rel="prefetch" href="/myblog/assets/js/82.96138a02.js"><link rel="prefetch" href="/myblog/assets/js/83.35b8c102.js"><link rel="prefetch" href="/myblog/assets/js/84.3389ac8e.js"><link rel="prefetch" href="/myblog/assets/js/85.62df5e4c.js"><link rel="prefetch" href="/myblog/assets/js/86.396bc322.js"><link rel="prefetch" href="/myblog/assets/js/9.62e3bf9b.js">
    <link rel="stylesheet" href="/myblog/assets/css/0.styles.99ff47a3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myblog/" class="home-link router-link-active"><!----> <span class="site-name">hyh的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myblog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端三剑客" class="dropdown-title"><!----> <span class="title" style="display:;">前端三剑客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/javascript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/myblog/blogs/basics/data.html" class="nav-link">前端资料网站</a></div><div class="nav-item"><a href="/myblog/blogs/basics/i18n.html" class="nav-link">国际化i18n</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/myblog/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端三剑客" class="dropdown-title"><!----> <span class="title" style="display:;">前端三剑客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/css/" class="nav-link">CSS</a></li><li class="dropdown-item"><!----> <a href="/myblog/blogs/basics/javascript/" class="nav-link">JavaScript</a></li></ul></div></div><div class="nav-item"><a href="/myblog/blogs/basics/data.html" class="nav-link">前端资料网站</a></div><div class="nav-item"><a href="/myblog/blogs/basics/i18n.html" class="nav-link">国际化i18n</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/myblog/" aria-current="page" class="sidebar-link">博客简介</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>es6基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ajax基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>git基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue2基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue3基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>lodash基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>浏览器基础篇</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/myblog/pages/e3ff84/" aria-current="page" class="active sidebar-link">浏览器工作原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/myblog/pages/e3ff84/#_1-为什么要学习浏览器的工作原理" class="sidebar-link">1.为什么要学习浏览器的工作原理</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/e3ff84/#_2-chrome架构-仅仅打开了1个页面-为什么有4个进程" class="sidebar-link">2.Chrome架构：仅仅打开了1个页面，为什么有4个进程？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/e3ff84/#_3-tcp协议-如何保证页面文件能被完整送达浏览器" class="sidebar-link">3. TCP协议：如何保证页面文件能被完整送达浏览器？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/e3ff84/#_4-http请求流程-为什么很多站点第二次打开速度会很快" class="sidebar-link">4.HTTP请求流程：为什么很多站点第二次打开速度会很快？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/e3ff84/#_5-导航流程-从输入url到页面展示-这中间发生了什么" class="sidebar-link">5.导航流程：从输入URL到页面展示，这中间发生了什么？</a></li><li class="sidebar-sub-header level2"><a href="/myblog/pages/e3ff84/#_6-渲染流程-上-html、css和javascript-是如何变成页面的" class="sidebar-link">6.渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？</a></li></ul></li><li><a href="/myblog/pages/9d7fbf/" class="sidebar-link">js执行逻辑</a></li><li><a href="/myblog/pages/497ad2/" class="sidebar-link">为什么js代码会出现爆栈</a></li><li><a href="/myblog/pages/c27c66/" class="sidebar-link">var缺陷</a></li><li><a href="/myblog/pages/9f5968/" class="sidebar-link">作用域链和闭包</a></li><li><a href="/myblog/pages/5fd9c7/" class="sidebar-link">this</a></li><li><a href="/myblog/pages/b579cc/" class="sidebar-link">堆和栈</a></li><li><a href="/myblog/pages/2b1549/" class="sidebar-link">垃圾回收</a></li><li><a href="/myblog/pages/0d2221/" class="sidebar-link">v8是怎样执行一段代码的</a></li><li><a href="/myblog/pages/94b8d4/" class="sidebar-link">setTimeout是怎么实现的</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-41062720><div class="articleInfo" data-v-41062720><ul class="breadcrumbs" data-v-41062720><li data-v-41062720><a href="/myblog/" title="首页" class="iconfont icon-home router-link-active" data-v-41062720></a></li> <li data-v-41062720><a href="/myblog/categories/?category=blogs" title="分类" data-v-41062720>blogs</a></li><li data-v-41062720><a href="/myblog/categories/?category=browser" title="分类" data-v-41062720>browser</a></li></ul> <div class="info" data-v-41062720><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-41062720><a href="javascript:;" data-v-41062720>2023-07-07</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">浏览器工作原理<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="_1-为什么要学习浏览器的工作原理"><a href="#_1-为什么要学习浏览器的工作原理" class="header-anchor">#</a> 1.为什么要学习浏览器的工作原理</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 准确评估 Web 开发项目的可行性
随着 Web 特性的极大丰富和浏览器性能的提升，越来越多的项目可以用 Web 来开发。所
以，了解浏览器是如何工作的，能够让你更加准确地决策是否可以采用 Web 来开发项目。
<span class="token number">2.</span> 从更高维度审视页面
作为一名合格的开发者，你还要具备一项重要的技能，那就是：要能站在用户体验角度来考
虑页面性能。
<span class="token number">3.</span> 在快节奏的技术迭代中把握本质
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_2-chrome架构-仅仅打开了1个页面-为什么有4个进程"><a href="#_2-chrome架构-仅仅打开了1个页面-为什么有4个进程" class="header-anchor">#</a> 2.Chrome架构：仅仅打开了1个页面，为什么有4个进程？</h2> <h3 id="_2-1-什么是并行处理"><a href="#_2-1-什么是并行处理" class="header-anchor">#</a> 2.1 什么是并行处理</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>计算机中的并行处理就是同一时刻处理多个任务 <span class="token punctuation">,</span>使用并行处理能大大提升性能。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>示例</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span><span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span>
<span class="token number">2.</span><span class="token constant">B</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token operator">/</span><span class="token number">5</span>
<span class="token number">3.</span><span class="token constant">C</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token operator">*</span><span class="token number">8</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>在编写代码的时候，我们可以把这个过程拆分为四个任务：
正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。
如果采用多线程，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前
三个任务；第二步，再执行第四个显示任务。
通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并
行处理能大大提升性能。
任务 <span class="token number">1</span> 是计算 <span class="token constant">A</span><span class="token operator">=</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span>；
任务 <span class="token number">2</span> 是计算 <span class="token constant">B</span><span class="token operator">=</span><span class="token number">20</span><span class="token operator">/</span><span class="token number">5</span>；
任务 <span class="token number">3</span> 是计算 <span class="token constant">C</span><span class="token operator">=</span><span class="token number">7</span><span class="token operator">*</span><span class="token number">8</span>；
任务 <span class="token number">4</span> 是显示最后计算的结果。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_2-2-线程-vs-进程"><a href="#_2-2-线程-vs-进程" class="header-anchor">#</a> 2.2 线程 VS 进程</h3> <p><strong>线程</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>进程</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该
程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的
一个运行环境叫进程。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="/myblog/assets/img/image-20230707204819491.8ff95d5f.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>进程与线程之间的关系</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 进程中的任意一线程执行出错，都会导致整个进程的崩溃
<span class="token number">2.</span> 线程之间共享进程中的数据。 线程之间可以对进程的公共数据进行读写操作。
<span class="token number">3.</span> 当一个进程关闭之后，操作系统会回收进程所占用的内存。
    当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作
    不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
<span class="token number">4.</span> 进程之间的内容相互隔离。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>4.描述</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，
也就避免出现进程 <span class="token constant">A</span> 写入数据到进程 <span class="token constant">B</span> 的情况。正是因为进程之间的数据是严格隔离的，
所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行
数据的通信，这时候，就需要使用用于进程间通信（<span class="token constant">IPC</span>）的机制了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="/myblog/assets/img/image-20230707204856124.36fc1ce1.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>从上图可以看出，线程 <span class="token number">1</span>、线程 <span class="token number">2</span>、线程 <span class="token number">3</span> 分别把执行的结果写入 <span class="token constant">A</span>、<span class="token constant">B</span>、<span class="token constant">C</span> 中，然后线程
<span class="token number">2</span> 继续从 <span class="token constant">A</span>、<span class="token constant">B</span>、<span class="token constant">C</span> 中读取数据，用来显示执行结果。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_2-3-单进程浏览器时代"><a href="#_2-3-单进程浏览器时代" class="header-anchor">#</a> 2.3 单进程浏览器时代</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>单进程浏览器
是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、
JavaScript 运行环境、渲染引擎和页面等。
缺点： <span class="token number">1.</span>不稳定  线程中任何一个地方出现问题 就会导致整个进程崩溃
       <span class="token number">2.</span> 不流畅  单线程 一次只能执行一个事件
       <span class="token number">3.</span>不安全， 打开多个页面 ，一个页面崩溃，失去响应，整个浏览器就会崩溃，会导致丢失未保存的数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_2-4-多进程浏览器时代"><a href="#_2-4-多进程浏览器时代" class="header-anchor">#</a> 2.4 多进程浏览器时代</h3> <p><img src="/myblog/assets/img/image-20230707205004238.32855ff0.png" alt="Algolia搜索"></p> <ol><li><strong>如何解决不稳定的问题</strong></li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code>由于进程是相互隔离的，所以当一个页面或者插件崩溃
时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就
完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="2"><li><strong>如何解决不流畅的问题</strong></li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code>javaScript 也是运行在渲染进程中
的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影
响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们
再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="3"><li>如何解决安全问题</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code>采用多进程架构的额外好处是可以使
用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，
但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌
面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里
面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>最新的Chrome进程架构</strong></p> <p><img src="/myblog/assets/img/image-20230707205034845.9c1dd548.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
<span class="token number">2.</span>渲染进程。核心任务是将 <span class="token constant">HTML</span>、<span class="token constant">CSS</span> 和 JavaScript 转换为用户可以与之交互的网页，
排版引擎 Blink 和 JavaScript 引擎 <span class="token constant">V8</span> 都是运行在该进程中，默认情况下，Chrome 会
为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
<span class="token number">3.</span><span class="token constant">GPU</span> 进程。其实，Chrome 刚开始发布的时候是没有 <span class="token constant">GPU</span> 进程的。而 <span class="token constant">GPU</span> 的使用初衷
是为了实现 3D <span class="token constant">CSS</span> 的效果，只是随后网页、Chrome 的 <span class="token constant">UI</span> 界面都选择采用 <span class="token constant">GPU</span> 来绘
制，这使得 <span class="token constant">GPU</span> 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了
<span class="token constant">GPU</span> 进程。
<span class="token number">4.</span>网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面
的，直至最近才独立出来，成为一个单独的进程。
<span class="token number">5.</span>插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保
证插件进程崩溃不会对浏览器和页面造成影响。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_3-tcp协议-如何保证页面文件能被完整送达浏览器"><a href="#_3-tcp协议-如何保证页面文件能被完整送达浏览器" class="header-anchor">#</a> 3. TCP协议：如何保证页面文件能被完整送达浏览器？</h2> <h3 id="_3-1-什么是ip"><a href="#_3-1-什么是ip" class="header-anchor">#</a> <strong>3.1 什么是IP</strong></h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>计算机的地址就称为 <span class="token constant">IP</span> 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>UDP：把数据包送达应用程序</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">IP</span> 是非常底层的协议，只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序，是交给浏览器还是交给王者荣耀？因此，需要基于 <span class="token constant">IP</span> 之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 <span class="token constant">UDP</span>。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">UDP</span> 中一个最重要的信息是端口号，端口号其实就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号 <span class="token constant">UDP</span> 就能把指定的数据包发送给指定的程序了，所以 <span class="token constant">IP</span> 通过 <span class="token constant">IP</span> 地址信息把数据包发送给指定的电脑，而 <span class="token constant">UDP</span> 通过端口号把数据包分发给正确的程序。和 <span class="token constant">IP</span> 头一样，端口号会被装进 <span class="token constant">UDP</span> 头里面，<span class="token constant">UDP</span> 头再和原始数据包合并组成新的 <span class="token constant">UDP</span> 数据包。<span class="token constant">UDP</span> 头中除了目的端口，还有源端口号等信息。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/myblog/assets/img/image-20230707205315534.20ec5564.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>下面我们一起来看下一个数据包从主机 <span class="token constant">A</span> 旅行到主机 <span class="token constant">B</span> 的路线：
上层将含有“极客时间”的数据包交给传输层；传输层会在数据包前面附加上 <span class="token constant">UDP</span> 头，组成新的 <span class="token constant">UDP</span> 数据包，再将新的 <span class="token constant">UDP</span> 数据包交给网络层；
<span class="token number">1.</span>网络层再将 <span class="token constant">IP</span> 头附加到数据包上，组成新的 <span class="token constant">IP</span> 数据包，并交给底层；
<span class="token number">2.</span>数据包被传输到主机 <span class="token constant">B</span> 的网络层，在这里主机 <span class="token constant">B</span> 拆开 <span class="token constant">IP</span> 头信息，并将拆开来的数据部分交给传输层；
<span class="token number">3.</span>在传输层，数据包中的 <span class="token constant">UDP</span> 头会被拆开，并根据 <span class="token constant">UDP</span> 中所提供的端口号，把数据部分交给上层的应用程序；
<span class="token number">4.</span>最终，含有“极客时间”信息的数据包就旅行到了主机 <span class="token constant">B</span> 上层应用程序这里。

在使用 <span class="token constant">UDP</span> 发送数据时，有各种因素会导致数据包出错，虽然 <span class="token constant">UDP</span> 可以校验数据是否正确，但是对于错误的数据包，<span class="token constant">UDP</span> 并不提供重发机制，只是丢弃当前的包，而且 <span class="token constant">UDP</span> 在发送之后也无法知道是否能达到目的地。虽说 <span class="token constant">UDP</span> 不能保证数据可靠性，但是传输速度却非常快，所以 <span class="token constant">UDP</span> 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_3-2-udp的问题"><a href="#_3-2-udp的问题" class="header-anchor">#</a> 3.2 UDP的问题</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">UDP</span> 来传输会存在两个问题：
<span class="token number">1.</span>数据包在传输过程中容易丢失；
<span class="token number">2.</span>大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 <span class="token constant">UDP</span> 协议并不知道如何组装这些数据包，从而把这些数据包不能还原成完整的文件。
如何解决：引入了<span class="token constant">TCP</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-3什么是tcp"><a href="#_3-3什么是tcp" class="header-anchor">#</a> 3.3什么是TCP</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">TCP</span>（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
相对于 <span class="token constant">UDP</span>，<span class="token constant">TCP</span> <span class="token literal-property property">有下面两个特点</span><span class="token operator">:</span>
<span class="token number">1.</span>对于数据包丢失的情况，<span class="token constant">TCP</span> 提供重传机制；
<span class="token number">2.</span><span class="token constant">TCP</span> 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
<span class="token constant">TCP</span>和<span class="token constant">UDP</span>是差不多的，但是<span class="token constant">UDP</span>数据在传输过程中容易丢失数据  ，<span class="token constant">TCP</span> 头的信息保证了一块大的数据传输的完整性。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="/myblog/assets/img/image-20230707205526293.4bc95b6a.png" alt="Algolia搜索"></p> <p>``一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段`
<img src="/myblog/assets/img/image-20230707205538739.cef7cc43.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>首先，建立连接阶段。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。<span class="token constant">TCP</span> 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 <span class="token constant">TCP</span> 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
<span class="token number">2.</span>其次，传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 <span class="token constant">TCP</span> 头中的序号为其排序，从而保证组成完整的数据。
<span class="token number">3.</span>最后，断开连接阶段。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。
        到这里你应该就明白了，<span class="token constant">TCP</span> 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>总结</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。
<span class="token constant">IP</span> 负责把数据包送达目的主机。
<span class="token constant">UDP</span> 负责把数据包送达具体应用。 只不过udp有可能会丢包，而tcp采用了很多复杂的机制，保证了数据的完整性
而 <span class="token constant">TCP</span> 保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-4-tcp和http的关系"><a href="#_3-4-tcp和http的关系" class="header-anchor">#</a> 3.4 TCP和http的关系</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>理解 <span class="token number">1</span><span class="token punctuation">.</span>Tcp是个梯子，http就是利用梯子来搬运货物 
理解 <span class="token number">2.</span><span class="token constant">TCP</span>理解为一个传送带，而<span class="token constant">HTTP</span>是一种具体类型的货物，<span class="token constant">TCP</span>负责运送这种货物并且保证不会弄丢
先通过三次握手建立tcp链接，链接建立好之后，发送http请求行和http请求头给服务器，然后服务器返回响应行，响应头和响应体，最终完成后通过四次挥手断开tcp链接！

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>ip协议保证了数据包传送到指定的目的主机
<span class="token number">2</span><span class="token punctuation">.</span>udp协议保证了数据包能传送到目的主机上的目标应用程序，速度快，但缺乏可靠性
<span class="token number">3</span><span class="token punctuation">.</span>tcp协议牺牲了速度来弥补了upd协议的不足，tcp具有回传机制保证数据传送的可靠性
<span class="token number">4.</span>这几种协议中都有一个概念“地址”，ip地址，端口号
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_4-http请求流程-为什么很多站点第二次打开速度会很快"><a href="#_4-http请求流程-为什么很多站点第二次打开速度会很快" class="header-anchor">#</a> 4.HTTP请求流程：为什么很多站点第二次打开速度会很快？</h2> <p><strong>什么是http</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span><span class="token constant">HTTP</span> 协议，正是建立在 <span class="token constant">TCP</span> 连接基础之上的。
<span class="token number">2.</span><span class="token constant">HTTP</span> 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 <span class="token constant">HTML</span> 文件、<span class="token constant">CSS</span> 文件、JavaScript 文件、图片、视频等。
<span class="token number">3.</span>此外，<span class="token constant">HTTP</span> 也是浏览器使用最广的协议
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_4-1-浏览器端发起-http-请求流程"><a href="#_4-1-浏览器端发起-http-请求流程" class="header-anchor">#</a> 4.1 浏览器端发起 HTTP 请求流程</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>如果你在浏览器地址栏里键入极客时间网站的地址：
<span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>time<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org<span class="token operator">/</span>index<span class="token punctuation">.</span>html， 那么接下来，浏览器会完成哪些动作呢？下面我们就一步一步详细“追踪”下。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>1.构建请求</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。
<span class="token constant">GET</span> <span class="token operator">/</span>index<span class="token punctuation">.</span>html <span class="token constant">HTTP1</span><span class="token number">.1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>2.查找缓存</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。
当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的
好处有：
<span class="token number">1.</span>缓解服务器端压力，提升性能（获取资源的耗时更短了）；
<span class="token number">2.</span>对于网站来说，缓存是实现快速资源加载的重要组成部分。
<span class="token number">3.</span>当然，如果缓存查找失败，就会进入网络请求过程了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>3.准备IP地址和端口</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>不过，先不急，在了解网络请求之前，我们需要先看看 <span class="token constant">HTTP</span> 和 <span class="token constant">TCP</span> 的关系。因为浏览器使用 <span class="token constant">HTTP</span> 协议作为应用层协议，用来封装请求的文本信息；并使用 <span class="token constant">TCP</span><span class="token operator">/</span><span class="token constant">IP</span> 作传输层协议将它发到网络上，所以在 <span class="token constant">HTTP</span> 工作开始之前，浏览器需要通过 <span class="token constant">TCP</span> 与服务器建立连接。也就是说 <span class="token constant">HTTP</span> 的内容是通过 <span class="token constant">TCP</span> 的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/myblog/assets/img/image-20230707205612422.2137c695.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>我们讲到建立 <span class="token constant">TCP</span> 连接的第一步就是需要准备 <span class="token constant">IP</span> 地址和端口号。那怎么获取 <span class="token constant">IP</span> 地址和端口号呢？这得看看我们现在有什么，我们有一个 <span class="token constant">URL</span> 地址，那么是否可以利用 <span class="token constant">URL</span> 地址来获取 <span class="token constant">IP</span> 和端口信息呢？
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>域名系统</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>由于 <span class="token constant">IP</span> 地址是数字标识，比如极客时间网站的 <span class="token constant">IP</span> 是 <span class="token number">39.106</span><span class="token number">.233</span><span class="token number">.176</span><span class="token punctuation">,</span> 难以记忆，但使用极客时间的域名（time<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org）就好记多了，所以基于这个需求又出现了一个服务，负责把域名和 <span class="token constant">IP</span> 地址做一一映射关系。这套域名映射为 <span class="token constant">IP</span> 的系统就叫做“域名系统”，简称 <span class="token constant">DNS</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>这样一路推导下来，你会发现在第一步浏览器会请求 <span class="token constant">DNS</span> 返回域名对应的 <span class="token constant">IP</span>。当然浏览器还提供了 <span class="token constant">DNS</span> 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。
拿到 <span class="token constant">IP</span> 之后，接下来就需要获取端口号了。通常情况下，如果 <span class="token constant">URL</span> 没有特别指明端口号，那么 <span class="token constant">HTTP</span> 协议默认是 <span class="token number">80</span> 端口。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>4.等待 TCP 队列</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>现在已经把端口和 <span class="token constant">IP</span> 地址都准备好了，那么下一步是不是可以建立 <span class="token constant">TCP</span> 连接了呢？
答案依然是“不行”。Chrome 有个机制，同一个域名同时最多只能建立 <span class="token number">6</span> 个 <span class="token constant">TCP</span> 连接，如果在同一个域名下同时有 <span class="token number">10</span> 个请求发生，那么其中 <span class="token number">4</span> 个请求会进入排队等待状态，直至进行中的请求完成。
当然，如果当前请求数量少于 <span class="token number">6</span>，会直接进入下一步，建立 <span class="token constant">TCP</span> 连接。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>5.建立TCP连接</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>排队等待结束之后，终于可以快乐地和服务器握手了，在 <span class="token constant">HTTP</span> 工作开始之前，浏览器通过 <span class="token constant">TCP</span> 与服务器建立连接。而 <span class="token constant">TCP</span> 的工作方式，我在上一篇文章中已经做过详细介绍了，如果有必要，你可以自行回顾下，这里我就不再重复讲述了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>6.发送HTTP请求</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>一旦建立了 <span class="token constant">TCP</span> 连接，浏览器就可以和服务器进行通信了。而 <span class="token constant">HTTP</span> 中的数据正是在这个通信过程中传输的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/myblog/assets/img/image-20230707205630898.de0aa6a2.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>首先浏览器会向服务器发送请求行，它包括了请求方法、请求 <span class="token constant">URI</span>（Uniform Resource Identifier）和 <span class="token constant">HTTP</span> 版本协议。发送请求行，就是告诉服务器浏览器需要什么资源，最常用的请求方法是 Get。比如，直接在浏览器地址栏键入极客时间的域名（time<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org），这就是告诉服务器要 Get 它的首页资源
在浏览器发送请求行命令之后，还要以请求头形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-2-服务器端处理-http-请求流程"><a href="#_4-2-服务器端处理-http-请求流程" class="header-anchor">#</a> 4.2 服务器端处理 HTTP 请求流程</h3> <p><strong>1. 返回请求</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>一旦服务器处理结束，便可以返回数据给浏览器了。你可以通过工具软件 curl 来查看返回请求数据，具体使用方法是在命令行中输入以下命令：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>curl <span class="token operator">-</span>i  https<span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">time.geekbang.org</span><span class="token regex-delimiter">/</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>注意这里加上了<span class="token operator">-</span>i是为了返回响应行、响应头和响应体的数据，返回的结果如下图所示，你可以结合这些数据来理解服务器是如何响应浏览器的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/myblog/assets/img/image-20230707205648000.cdd9328d.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 首先服务器会返回响应行，包括协议版本和状态码。但并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么办呢？服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：最常用的状态码是 <span class="token number">200</span>，表示处理成功；如果没有找到页面，则会返回 <span class="token number">404</span>。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">2.</span> 随后，正如浏览器会随同请求发送请求头一样，服务器也会随同响应向浏览器发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（<span class="token constant">JSON</span>、<span class="token constant">HTML</span>、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。发送完响应头后，服务器就可以继续发送响应体的数据，通常，响应体就包含了 <span class="token constant">HTML</span> 的实际内容。以上这些就是服务器响应浏览器的具体过程。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>2.断开连接</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 <span class="token constant">TCP</span> 连接。不过如果浏览器或者服务器在其头信息中加入了：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// Connection:Keep-Alive </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>那么 <span class="token constant">TCP</span> 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 <span class="token constant">TCP</span> 连接发送请求。保持 <span class="token constant">TCP</span> 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 <span class="token constant">TCP</span> 连接。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>3. 重定向</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>到这里似乎请求流程快结束了，不过还有一种情况你需要了解下，比如当你在浏览器中打开 geekbang<span class="token punctuation">.</span>org 后，你会发现最终打开的页面地址是 https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org。这两个 <span class="token constant">URL</span> 之所以不一样，是因为涉及到了一个重定向操作。跟前面一样，你依然可以使用 curl 来查看下请求 geekbang<span class="token punctuation">.</span>org 会返回什么内容？
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>在控制台输入如下命令：</code></p> <div class="language-cmd line-numbers-mode"><pre class="language-text"><code>curl -I geekbang.org
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>注意这里输入的参数是<span class="token operator">-</span><span class="token constant">I</span>，和<span class="token operator">-</span>i不一样，<span class="token operator">-</span><span class="token constant">I</span>表示只需要获取响应头和响应行数据，而不需要获取响应体的数据，最终返回的数据如下图所示
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="/myblog/assets/img/image-20230707205703036.31031f50.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>从图中你可以看到，响应行返回的状态码是 <span class="token number">301</span>，状态 <span class="token number">301</span> 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。这也就解释了为什么输入的是 geekbang<span class="token punctuation">.</span>org，最终打开的却是 https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org 了。
不过也不要认为这种跳转是必然的。如果你打开 https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">12306</span><span class="token punctuation">.</span>cn，你会发现这个站点是打不开的。这是因为 <span class="token number">12306</span> 的服务器并没有处理跳转，所以必须要手动输入完整的 https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span><span class="token number">12306</span><span class="token punctuation">.</span>cn 才能打开页面。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-3为什么很多站点第二次打开速度会快很多"><a href="#_4-3为什么很多站点第二次打开速度会快很多" class="header-anchor">#</a> 4.3为什么很多站点第二次打开速度会快很多</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据
哪些数据会被缓存<span class="token operator">?</span>
    <span class="token number">1.</span><span class="token constant">DNS</span> 缓存
    <span class="token number">2.</span>页面资源缓存
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707205735840.fb27fa27.png" alt="Algolia搜索"> <code>缓存查找流程示意图</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>当服务器返回 <span class="token constant">HTTP</span> 响应头给浏览器时，浏览器是通过响应头中的 Cache<span class="token operator">-</span>Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache<span class="token operator">-</span>Control 中的 Max<span class="token operator">-</span>age 参数来设置的，比如上图设置的缓存过期时间是 <span class="token number">2000</span> 秒。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>Cache<span class="token operator">-</span>Control<span class="token operator">:</span>Max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">2000</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>这也就意味着，在该缓存资源还未过期的情况下<span class="token punctuation">,</span> 如果再次请求该资源，会直接返回缓存中的资源给浏览器。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>If<span class="token operator">-</span>None<span class="token operator">-</span>Match<span class="token operator">:</span><span class="token string">&quot;4f80f-13c-3a1xb12a&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>服务器收到请求头后，会根据 If<span class="token operator">-</span>None<span class="token operator">-</span>Match 的值来判断请求的资源是否有更新。如果没有更新，就返回 <span class="token number">304</span> 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”
<span class="token number">2.</span>如果资源有更新，服务器就直接返回最新资源给浏览器。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-4登录状态是如何保持的"><a href="#_4-4登录状态是如何保持的" class="header-anchor">#</a> 4.4登录状态是如何保持的</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 <span class="token constant">POST</span> 方法提交用户登录信息给服务器。
<span class="token number">2.</span>服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set<span class="token operator">-</span>Cookie 字段里，如下所示，然后把响应头发送给浏览器。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>Set<span class="token operator">-</span>Cookie<span class="token operator">:</span> <span class="token constant">UID</span><span class="token operator">=</span>3431uad<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set<span class="token operator">-</span>Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把<span class="token constant">UID</span><span class="token operator">=</span>3431uad保持到本地。
<span class="token number">2.</span>当用户再次访问时，浏览器会发起 <span class="token constant">HTTP</span> 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">Cookie</span><span class="token operator">:</span> <span class="token constant">UID</span><span class="token operator">=</span>3431uad<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>服务器在收到 <span class="token constant">HTTP</span> 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含<span class="token constant">UID</span><span class="token operator">=</span>3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。
<span class="token number">2.</span>浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>``好了，通过这个流程你可以知道浏览器页面状态是通过使用 Cookie 来实现的。Cookie 流程可以参考下图：</strong></p> <p>​ <img src="/myblog/assets/img/image-20230707205754373.6e18adf4.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>简单地说，如果服务器端发送的响应头内有 Set<span class="token operator">-</span>Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>总结</strong>
​ <img src="/myblog/assets/img/image-20230707205806289.f5436a32.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>从图中可以看到，浏览器中的 <span class="token constant">HTTP</span> 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 <span class="token constant">IP</span> 和端口、等待 <span class="token constant">TCP</span> 队列、建立 <span class="token constant">TCP</span> 连接、发起 <span class="token constant">HTTP</span> 请求、服务器处理请求、服务器返回请求和断开连接。
<span class="token number">2.</span>然后我还通过 <span class="token constant">HTTP</span> 请求路径解答了两个经常会碰到的问题，一个涉及到了 Cache 流程，另外一个涉及到如何使用 Cookie 来进行状态管理。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-5-如果一个页面的网络加载时间过久-你是如何分析卡在哪个阶段的"><a href="#_4-5-如果一个页面的网络加载时间过久-你是如何分析卡在哪个阶段的" class="header-anchor">#</a> 4.5 如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>js性能太差，阻塞页面因为浏览器解析过程中，遇到某个请求慢阻塞页面的加载
<span class="token number">2.</span>网络传输丢包比较严重，需要不断重传。然后通过ping curl看看对应的时延高不高。
<span class="token number">3.</span> 然后通过wireshake看看具体哪里出了问题。
<span class="token number">4.</span>假如别人访问很快，自己电脑很慢，就要看看自己客户端是否有问题了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_5-导航流程-从输入url到页面展示-这中间发生了什么"><a href="#_5-导航流程-从输入url到页面展示-这中间发生了什么" class="header-anchor">#</a> 5.导航流程：从输入URL到页面展示，这中间发生了什么？</h2> <p>​ <img src="/myblog/assets/img/image-20230707205842256.3afcbe29.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>浏览器进程主要负责用户交互、子进程管理和文件储存等功能。
网络进程是面向渲染进程和浏览器进程等提供网络下载功能。
渲染进程的主要职责是把从网络下载的 <span class="token constant">HTML</span>、JavaScript、<span class="token constant">CSS</span>、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>上图的大概过程</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>首先，浏览器进程接收到用户输入的 <span class="token constant">URL</span> 请求，浏览器进程便将该 <span class="token constant">URL</span> 转发给网络进程。
<span class="token number">2.</span>然后，在网络进程中发起真正的 <span class="token constant">URL</span> 请求。
<span class="token number">3.</span>接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
<span class="token number">4.</span><span class="token function">浏览器进程接收到网络进程的响应头数据之后，发送“提交导航</span> <span class="token punctuation">(</span>CommitNavigation<span class="token punctuation">)</span>”消息到渲染进程；
<span class="token number">5.</span>渲染进程接收到“提交导航”的消息之后，便开始准备接收 <span class="token constant">HTML</span> 数据，接收数据的方式是直接和网络进程建立数据管道；
<span class="token number">6.</span>最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。
<span class="token number">7.</span>浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。
这其中，用户发出 <span class="token constant">URL</span> 请求到页面开始解析的这个过程，就叫做导航。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_5-1从输入url到页面展示"><a href="#_5-1从输入url到页面展示" class="header-anchor">#</a> 5.1<strong>从输入URL到页面展示</strong></h3> <p><strong>1.用户输入</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 <span class="token constant">URL</span>。
<span class="token number">1.</span>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 <span class="token constant">URL</span>。
<span class="token number">2.</span>如果判断输入内容符合 <span class="token constant">URL</span> 规则，比如输入的是 time<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 <span class="token constant">URL</span>，如 https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>time<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。

当前页面没有监听 beforeunload 事件或者同意了继续后续流程，那么浏览器便进入下图的状态：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707205905045.9f5cd494.png" alt="Algolia搜索"></p> <div class="language-tex line-numbers-mode"><pre class="language-tex"><code>从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>2. URL请求过程</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（<span class="token constant">IPC</span>）把 <span class="token constant">URL</span> 请求发送至网络进程，网络进程接收到 <span class="token constant">URL</span> 请求后，会在这里发起真正的 <span class="token constant">URL</span> 请求流程。那具体流程是怎样的呢？
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 <span class="token constant">DNS</span> 解析，以获取请求域名的服务器 <span class="token constant">IP</span> 地址。如果请求协议是 <span class="token constant">HTTPS</span>，那么还需要建立 <span class="token constant">TLS</span> 连接。
<span class="token number">2.</span>接下来就是利用 <span class="token constant">IP</span> 地址和服务器建立 <span class="token constant">TCP</span> 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。
<span class="token number">2.</span>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。（为了方便讲述，下面我将服务器返回的响应头和响应行统称为响应头。）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>2.1重定向</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 <span class="token number">301</span> 或者 <span class="token number">302</span>，那么说明服务器需要浏览器重定向到其他 <span class="token constant">URL</span>。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 <span class="token constant">HTTP</span> 或者 <span class="token constant">HTTPS</span> 请求，一切又重头开始了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>``比如，我们在终端里输入以下命令：`</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>curl <span class="token operator">-</span><span class="token constant">I</span> <span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">time.geekbang.org</span><span class="token regex-delimiter">/</span></span>
curl <span class="token operator">-</span><span class="token constant">I</span> <span class="token operator">+</span> <span class="token constant">URL</span>的命令是接收服务器返回的响应头的信息。执行命令后，我们看到服务器返回的响应头信息如下：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707205923850.9dcbcd1b.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>从图中可以看出，极客时间服务器会通过重定向的方式把所有 <span class="token constant">HTTP</span> 请求转换为 <span class="token constant">HTTPS</span> 请求。也就是说你使用 <span class="token constant">HTTP</span> 向极客时间服务器请求时，服务器会返回一个包含有 <span class="token number">301</span> 或者 <span class="token number">302</span> 状态码响应头，并把响应头的 Location 字段中填上 <span class="token constant">HTTPS</span> 的地址，这就是告诉了浏览器要重新导航到新的地址上。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>``下面我们再使用 HTTPS 协议对极客时间发起请求，看看服务器的响应头信息是什么样子的。`</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>	curl <span class="token operator">-</span><span class="token constant">I</span> <span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">time.geekbang.org</span><span class="token regex-delimiter">/</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707205946171.e23435a8.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>从图中可以看出，服务器返回的响应头的状态码是 <span class="token number">200</span>，这是告诉浏览器一切正常，可以继续往下处理该请求了。
好了，以上是重定向内容的介绍。现在你应该理解了，在导航过程中，如果服务器响应行的状态码包含了 <span class="token number">301</span>、<span class="token number">302</span> 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 <span class="token number">200</span>，那么表示浏览器可以继续处理该请求。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>2.2 响应数据类型处理</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>在处理了跳转信息之后，我们继续导航流程的分析。<span class="token constant">URL</span> 请求的数据类型，有时候是一个下载类型，有时候是正常的 <span class="token constant">HTML</span> 页面，那么浏览器是如何区分它们呢？

答案是 &quot;Content<span class="token operator">-</span>Type。Content<span class="token operator">-</span>Type 是 <span class="token constant">HTTP</span> 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content<span class="token operator">-</span>Type 的值来决定如何显示响应体的内容。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>```这里我们还是以极客时间为例，看看极客时间官网返回的 Content-Type 值是什么。在终端输入以下命令：`</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>curl <span class="token operator">-</span><span class="token constant">I</span> <span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">time.geekbang.org</span><span class="token regex-delimiter">/</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707210006210.f38532d9.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token string">'从图中可以看到，响应头中的 Content-type 字段的值是 text/html，这就是告诉浏览器，服务器返回的数据是 HTML 格式'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>``接下来我们再来利用 curl 来请求极客时间安装包的地址，如下所示：`</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>curl <span class="token operator">-</span><span class="token constant">I</span> <span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>res001<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org<span class="token operator">/</span>apps<span class="token operator">/</span>geektime<span class="token operator">/</span>android<span class="token operator">/</span><span class="token number">2.3</span><span class="token number">.1</span><span class="token operator">/</span>official<span class="token operator">/</span>geektime_2<span class="token punctuation">.</span><span class="token number">3.1_20190527</span><span class="token operator">-</span>2136_offical<span class="token punctuation">.</span>apk
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707210015472.aa49d532.png" alt="Algolia搜索"></p> <p><strong>注意：</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>从返回的响应头信息来看，其 Content<span class="token operator">-</span>Type 的值是 application<span class="token operator">/</span>octet<span class="token operator">-</span>stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。
<span class="token number">2.</span>需要注意的是，如果服务器配置 Content<span class="token operator">-</span>Type 不正确，比如将 text<span class="token operator">/</span>html 类型配置成 application<span class="token operator">/</span>octet<span class="token operator">-</span>stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。
<span class="token number">3.</span>所以，不同 Content<span class="token operator">-</span>Type 的后续处理流程也截然不同。如果 Content<span class="token operator">-</span>Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 <span class="token constant">URL</span> 请求的导航流程就此结束。但如果是 <span class="token constant">HTML</span>，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>3.准备渲染进程</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>``比如我从极客时间的首页里面打开了另外一个页面——算法训练营，我们看下图的 Chrome 的任务管理器截图：`</p> <p>​ <img src="/myblog/assets/img/image-20230707210034530.8d8aab10.png" alt="Algolia搜索"></p> <p>``从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程 ID 是 23601。`</p> <h3 id="_5-2同一站点"><a href="#_5-2同一站点" class="header-anchor">#</a> 5.2同一站点</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>那什么情况下多个页面会同时运行在一个渲染进程中呢？
要解决这个问题，我们就需要先了解下什么是同一站点（same<span class="token operator">-</span>site）。具体地讲，我们将“同一站点”定义为根域名（例如，geekbang<span class="token punctuation">.</span>org）加上协议（例如，https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span> 或者 http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>time<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org
<span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org
<span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>geekbang<span class="token punctuation">.</span>org<span class="token operator">:</span><span class="token number">8080</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>``它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。`</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process<span class="token operator">-</span>per<span class="token operator">-</span>site<span class="token operator">-</span>instance。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_5-3打开一个新的页面采用的渲染进程策略"><a href="#_5-3打开一个新的页面采用的渲染进程策略" class="header-anchor">#</a> 5.3打开一个新的页面采用的渲染进程策略</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>打开一个新页面采用的渲染进程策略就是：
<span class="token number">1.</span>通常情况下，打开新的页面都会使用单独的渲染进程；
<span class="token number">2.</span>如果从 <span class="token constant">A</span> 页面打开 <span class="token constant">B</span> 页面，且 <span class="token constant">A</span> 和 <span class="token constant">B</span> 都属于同一站点的话，那么 <span class="token constant">B</span> 页面复用 <span class="token constant">A</span> 页面的渲染进程；
<span class="token number">3.</span>如果是其他情况，浏览器进程则会为 <span class="token constant">B</span> 创建一个新的渲染进程。
<span class="token number">4.</span>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>4.提交文档</strong></p> <p>``所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：`</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
<span class="token number">2.</span>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
<span class="token number">3.</span>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
<span class="token number">4.</span>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 <span class="token constant">URL</span>、前进后退的历史状态，并更新 Web 页面。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>``其中，当渲染进程确认提交之后，更新内容如下图所示：`</p> <p>​ <img src="/myblog/assets/img/image-20230707210112385.0d6ed648.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。
到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>5.渲染阶段</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>一旦文档被提交，渲染进程便开始页面解析和子资源加载了，关于这个阶段的完整过程，我会在下一篇文章中来专门介绍。这里你只需要先了解一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。如下所示：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707210153622.1cb756f0.png" alt="Algolia搜索"></p> <h2 id="_6-渲染流程-上-html、css和javascript-是如何变成页面的"><a href="#_6-渲染流程-上-html、css和javascript-是如何变成页面的" class="header-anchor">#</a> 6.渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？</h2> <p>``这中间的<strong>渲染模块</strong>就是我们今天要讨论的主题。为了能更好地理解下文，你可以先结合下图快速抓住 HTML、CSS 和 JavaScript 的含义：`
​ <img src="/myblog/assets/img/image-20230707210219444.f5fe796c.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的
<span class="token constant">HTML</span> 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线，其
大致流程如下图所示：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707210229513.e360b80d.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 <span class="token constant">DOM</span> 树、样式计算、布局阶
段、分层、绘制、分块、光栅化和合成。内容比较多，我会用两篇文章来为你详细讲解这各
个子阶段。接下来，在介绍每个阶段的过程中，你应该重点关注以下三点内容：
开始每个子阶段都有其输入的内容；
然后每个子阶段有其处理过程；
最终每个子阶段会生成输出内容。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_1-构建dom树"><a href="#_1-构建dom树" class="header-anchor">#</a> <strong>1.构建DOM树</strong></h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>为什么要构建 <span class="token constant">DOM</span> 树呢？这是因为浏览器无法直接理解和使用 <span class="token constant">HTML</span>，所以需要将
<span class="token constant">HTML</span> 转换为浏览器能够理解的结构——<span class="token constant">DOM</span> 树。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707210251623.8842fe8f.png" alt="Algolia搜索"></p> <p>``其中每个点我们称为节点，相连的节点称为父子节点`
​ <img src="/myblog/assets/img/image-20230707210310745.9775eef0.png" alt="Algolia搜索"></p> <h3 id="_2-样式计算-recalculate-style"><a href="#_2-样式计算-recalculate-style" class="header-anchor">#</a> <strong>2.样式计算（Recalculate Style）</strong></h3> <p>``样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三
步来完成。`</p> <h4 id="_2-1-把-css-转换为浏览器能够理解的结构"><a href="#_2-1-把-css-转换为浏览器能够理解的结构" class="header-anchor">#</a> <strong>2.1  把 CSS 转换为浏览器能够理解的结构</strong></h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>和 <span class="token constant">HTML</span> 文件一样，浏览器也是无法直接理解这些纯文本的 <span class="token constant">CSS</span> 样式，所以当渲染引擎接
收到 <span class="token constant">CSS</span> 文本时，会执行一个转换操作，将 <span class="token constant">CSS</span> 文本转换为浏览器可以理解的结构——
styleSheets。
为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入
document<span class="token punctuation">.</span>styleSheets，然后就看到如下图所示的结构：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707210426609.77f1dd1b.png" alt="Algolia搜索">
​ <img src="/myblog/assets/img/image-20230707210344232.306c89ad.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>从图中可以看出，这个样式表包含了很多种样式，已经把那三种来源的样式都包含进去了。当然样式表的具体结构不是我们今天讨论的重点，你只需要知道渲染引擎会把获取到的<span class="token constant">CSS</span> 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_2-2转换样式表中的属性值-使其标准化"><a href="#_2-2转换样式表中的属性值-使其标准化" class="header-anchor">#</a> <strong>2. 2转换样式表中的属性值，使其标准化</strong></h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>现在我们已经把现有的 <span class="token constant">CSS</span> 文本转化为浏览器可以理解的结构了，那么接下来就要对其进
行属性值的标准化操作。
要理解什么是属性值标准化，你可以看下面这样一段 <span class="token constant">CSS</span> 文本：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code>body { font-size: 2em }
p {color:blue;}
span {display: none}
div {font-weight: bold}
div p {color:green;}
div {color:red; }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>可以看到上面的 <span class="token constant">CSS</span> 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707210507339.75265b35.png" alt="Algolia搜索"></p> <h4 id="_2-3-计算出-dom-树中每个节点的具体样式"><a href="#_2-3-计算出-dom-树中每个节点的具体样式" class="header-anchor">#</a> <strong>2. 3 计算出 DOM 树中每个节点的具体样式</strong></h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>现在样式的属性已被标准化了，接下来就需要计算 <span class="token constant">DOM</span> 树中每个节点的样式属性了，如
何计算呢？
这就涉及到 <span class="token constant">CSS</span> 的继承规则和层叠规则了。
<span class="token number">1.</span>首先是 <span class="token constant">CSS</span> 继承。<span class="token constant">CSS</span> 继承就是每个 <span class="token constant">DOM</span> 节点都包含有父节点的样式。
<span class="token number">2.</span>样式计算过程中的第二个规则是样式层叠。层叠是 <span class="token constant">CSS</span> 的一个基本特征，它是一个定义了
如何合并来自多个源的属性值的算法。它在 <span class="token constant">CSS</span> 处于核心地位，<span class="token constant">CSS</span> 的全称“层叠样式
表
<span class="token number">3.</span>总之，样式计算阶段的目的是为了计算出 <span class="token constant">DOM</span> 节点中每个元素的具体样式，在计算过程
中需要遵守 <span class="token constant">CSS</span> 的继承和层叠两个规则。这个阶段最终输出的内容是每个 <span class="token constant">DOM</span> 节点的样
式，并被保存在 ComputedStyle 的结构内。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_3-布局阶段"><a href="#_3-布局阶段" class="header-anchor">#</a> <strong>3.布局阶段</strong></h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code>现在，我们有 <span class="token constant">DOM</span> 树和 <span class="token constant">DOM</span> 树中元素的样式，但这还不足以显示页面，因为我们还不
知道 <span class="token constant">DOM</span> 元素的几何位置信息。那么接下来就需要计算出 <span class="token constant">DOM</span> 树中可见元素的几何位
置，我们把这个计算过程叫做布局。
Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_3-1-创建布局树"><a href="#_3-1-创建布局树" class="header-anchor">#</a> 3.1 创建布局树</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>`你可能注意到了 <span class="token constant">DOM</span> 树还含有很多不可见的元素，比如 head 标签，还有使用了
<span class="token literal-property property">display</span><span class="token operator">:</span>none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布
局树。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>`为了构建布局树，浏览器大体上完成了下面这些工作：
遍历 <span class="token constant">DOM</span> 树中的所有可见节点，并把这些节点加到布局中；
而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如
body<span class="token punctuation">.</span>p<span class="token punctuation">.</span>span 这个元素，因为它的属性包含 dispaly<span class="token operator">:</span>none，所以这个元素也没有被包进
布局树。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707210605206.59b077ea.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>`从图中可以看出，本节内容我们介绍了渲染流程的前三个阶段：<span class="token constant">DOM</span> 生成、样式计算和布局。要点可大致总结为如下：在 <span class="token constant">HTML</span> 页面内容被提交给渲染引擎之后，渲染引擎首先将 <span class="token constant">HTML</span> 解析为浏览器可以理解的 <span class="token constant">DOM</span>；然后根据 <span class="token constant">CSS</span> 样式表，计算出 <span class="token constant">DOM</span> 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_3-2布局计算"><a href="#_3-2布局计算" class="header-anchor">#</a> 3.2布局计算</h4> <p><strong>渲染流水线大总结</strong>
​ <img src="/myblog/assets/img/image-20230707210848550.04027185.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>结合上图，一个完整的渲染流程大致可总结为如下：
<span class="token number">1.</span> 渲染进程将 <span class="token constant">HTML</span> 内容转换为能够读懂的<span class="token constant">DOM</span> 树结构。
<span class="token number">2.</span> 渲染引擎将 <span class="token constant">CSS</span> 样式表转化为浏览器可以理解的styleSheets，计算出 <span class="token constant">DOM</span> 节点的样式。
<span class="token number">3.</span> 创建布局树，并计算元素的布局信息。
<span class="token number">4.</span> 对布局树进行分层，并生成分层树。
<span class="token number">5.</span> 为每个图层生成绘制列表，并将其提交到合成线程。
<span class="token number">6.</span> 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
<span class="token number">7.</span> 合成线程发送绘制图块命令DrawQuad给浏览器进程。
<span class="token number">8.</span> 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_4-回流-重排"><a href="#_4-回流-重排" class="header-anchor">#</a> 4.回流(重排)</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//更新了元素的几何属性,就会引起回流，</span>
如果你通过 JavaScript 或者 <span class="token constant">CSS</span> 修改元素的几何位置属性，例如改变元
素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫
重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_5-重绘"><a href="#_5-重绘" class="header-anchor">#</a> 5.重绘</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//更新元素的绘制属性（重绘）</span>
如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_6-直接合成阶段"><a href="#_6-直接合成阶段" class="header-anchor">#</a> 6.直接合成阶段</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//那如果你更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>​ <img src="/myblog/assets/img/image-20230707210912807.f6cebe5e.png" alt="Algolia搜索"></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>我们使用了 <span class="token constant">CSS</span> 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_7-具体的实践方法能减少重绘、重排呢"><a href="#_7-具体的实践方法能减少重绘、重排呢" class="header-anchor">#</a> 7.具体的实践方法能减少重绘、重排呢？</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token number">1.</span> 使用 <span class="token keyword">class</span> 操作样式，而不是频繁操作 style
<span class="token number">2.</span> 避免使用 table 布局
<span class="token number">3.</span> vue <span class="token operator">/</span> react 数据驱动思想 <span class="token operator">:</span>我们自己不操作<span class="token constant">DOM</span>，我们只操作数据，让框架帮我们根据数据渲染视图（框架内部本身对于<span class="token constant">DOM</span>的回流和重绘以及其它性能优化做的非常好）
<span class="token number">4.</span> Debounce window resize 事件…
<span class="token number">5.</span><span class="token literal-property property">分离读写操作（现代浏览器的渲染队列的机制）（重要）</span><span class="token operator">:</span>
<span class="token comment">//现代浏览器中默认增加了“渲染队列的机制”，以此来减少DOM的回流和重绘</span>
 遇到一行修改样式的代码，先放到渲染队列中，继续看 下面一行代码 是否还为修改样式的，如果是继续增加到渲染队列中<span class="token operator">...</span>直到下面的代码不再是修改样式的，而是获取样式的代码！此时不再向渲染队列中增加，把之前渲染队列中要修改的样式一次性渲染到页面中，引发一次<span class="token constant">DOM</span>的回流和重绘 但是有的时候我们还需要浏览器多次回流：例如：先设置动画，渲染后，在去改变样式，让其有动画效果
<span class="token number">6.</span>元素批量修改（重要）
文档碎片：临时创建的一个存放文档的容器，我们可以把新创建的<span class="token constant">LI</span>，存放到容器中，当所有的<span class="token constant">LI</span>都存储完，我们统一把容器中的内容增加到页面中（只触发一次回流）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></div></div> <!----> <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/myblog/pages/7e3be3/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">小程序打包上线到测试服和正式服</div></a> <a href="/myblog/pages/9d7fbf/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">js执行逻辑</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/myblog/pages/7e3be3/" class="prev">小程序打包上线到测试服和正式服</a></span> <span class="next"><a href="/myblog/pages/9d7fbf/">js执行逻辑</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/myblog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/myblog/" class="router-link-active"><div>
            首页
            <!----></div></a> <span class="date"></span></dt></dl><dl><dd>02</dd> <dt><a href="/myblog/pages/2faf0d/"><div>
            vscode操作git
            <!----></div></a> <span class="date">07-10</span></dt></dl><dl><dd>03</dd> <dt><a href="/myblog/pages/e6d2d9/"><div>
            前端资料网站
            <!----></div></a> <span class="date">07-10</span></dt></dl> <dl><dd></dd> <dt><a href="/myblog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> <!----></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/myblog/assets/js/app.86e991b9.js" defer></script><script src="/myblog/assets/js/2.dd8fbd6f.js" defer></script><script src="/myblog/assets/js/3.39ee49ac.js" defer></script>
  </body>
</html>
